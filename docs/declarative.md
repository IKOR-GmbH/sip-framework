# SIP Declarative Adapter

[TOC]

## Description

SIP Declarative Adapter concept relies on using best practices in order to provide developers
with a tool for building unified adapters. It is a structured approach for building integration adapters.
By using predefined SIP constructs (Connector, Integration scenario, Connector Group, Composite process) 
the adapter development is streamlined and built by the SIP Framework. 


## Concepts

### Common Domain Model (CDM)

CDM is a model which is used in connecting different non-compatible systems. 
It is also referred to as _Canonical Data Model_ in the standard integration patterns. 
It is the shared data model that needs to be understood by all **Connectors** participating in an **Integration scenario**. 
Each **Integration scenario** specifies the CDM that is used for it, 
while the **Connectors** participating in the scenario act as interpreters 
and translate between the CDM and the model used by the external system they are connecting to.

### Integration Scenario

A scenario is a means of linking connectors into one fluent flow.
They are used to define a specific integration flow, usually one concrete operation, between integration sides. 
Each adapter contains one or more scenarios that are related to the scope of the adapter itself.

### Connector group

Connector groups are used for grouping connectors based on the system they belong to.

### Connector

A connector is a holder of an **external** endpoint and represents one integration side. 
One connector would typically only talk to multiple external systems if they form a dependent unit - otherwise, 
for independent systems, separate connectors should be provided, one for each individual system. 
Their duty is to provide necessary processing and transformation into/from the Common Domain Model. 
They can be either _Inbound_ or _Outbound_, with Inbound having Rest and SOAP as pre-built subtypes.

### Composite Process

Combines multiple Integration Scenarios into one flow. 
Its purpose is to allow reuse of the integration scenarios and provide mappings between different CDMs, 
define order of execution and conditional execution.

### Orchestration

SIP Framework allows custom code to be added to multiple predefined points in the adapter
that can control the behaviour of the specific declarative element. 
At the end SIP framework builds the adapter using predefined SIP constructs (mapping, control flow, etc.) 
and custom code defined by the developer. 
Custom behaviour supplied by the developer in different places in the adapter is called "orchestration".

There are 3 points of orchestration:
* Connectors - Behavior of the connector that influences request and (optional) response flow. This orchestration can be written in **Camel and Java**.
* Integration scenario - Execution order of Connectors, control flow, and response aggregation. This orchestration can be written in custom **SIP Orchestration DSL and Java**. 
* Composite process - Execution order of integration scenarios, control flow and mappings. This orchestration can be written in custom **SIP Orchestration DSL and Java**.


## Configuration

To enable or disable declarative adapter building the following configuration property is used:

```yaml
sip:
  core:
    declarativestructure:
      enabled: true # enabled by default
```

## How to build

Building one adapter requires implementation of previously mentioned concepts.

### Integration Scenarios

In order to create a scenario first we need to create a class which extends IntegrationScenarioBase. 
Then, annotate it with @IntegrationScenario and fill in the required fields:

- *scenarioId* - unique identifier of a scenario, used in connectors to link them
- *requestModel* - represents the common domain model, that both integration sides communicate through
- *responseModel* (optional) - represents the response domain model, which is expected to be returned from outbound side of the flow
- *pathToDocumentationResource* (optional) - provides path to scenario documentation files
  (By default it will look for file in _document/structure/integration-scenarios/{scenarioId}.md_)

```java
  @IntegrationScenario(
        scenarioId = DemoScenario.ID, 
        requestModel = DemoCDMRequest.class, 
        responseModel = DemoCDMResponse.class)
  public class DemoScenario extends IntegrationScenarioBase {
    public static final String ID = "Demo scenario";
  }
```

### Connector Groups

Similar to scenarios, we first need to extend ConnectorGroupBase and also annotate the class with @ConnectorGroup.
Defining connector group is optional. If a connector group is not represented in code, but is used in a connector, 
it will be automatically generated by the framework with the ID declared in the connector.
Fields that are available are:

- *groupId* - unique connector group identifier
- *pathToDocumentationResource* (optional) - provides path to documentation files.
  (By default it will look for file in _document/structure/connector-groups/{groupId}.md_)

```java
  @ConnectorGroup(groupId = DemoConnectorGroup.ID)
  public class DemoConnectorGroup extends ConnectorGroupBase {
    public static final String ID = "SIP1";
  }
```

### Connectors

**Inbound**

Inbound connectors are the entry point to an adapter. 
They need to extend _GenericInboundConnectorBase_, or one of the dedicated implementations (REST and SOAP),
and override necessary methods.
Also, @InboundConnector annotation is required, with the following fields:

- *connectorId* (optional) - unique identifier of a connector (automatically generated if missing)
- *connectorGroup* - id of the connector group it belongs to
- *integrationScenario* - id of the scenario to which it provides data
- *requestModel* - model which is expected be received on the input endpoint
- *responseModel* (optional) - model which is expected be returned to the caller
- *domains* (optional) - list of domains this connector is a part of 
- *pathToDocumentationResource* (optional) - provides path to documentation files.
  (By default it will look for file in _document/structure/connectors/{connectorId}.md_)

Defining connector behavior is done by overriding certain methods and adding custom implementation.

First, *EndpointConsumerBuilder defineInitiatingEndpoint()* it is used to define the input endpoint.
StaticEndpointBuilders can be used to provide the endpoint definition. 
Under the hood connector uses **Apache Camel** endpoints.

Next is defining processing and transformation. 
This is done in *Orchestrator<ConnectorOrchestrationInfo> defineTransformationOrchestrator()*.
Here an Orchestrator needs to be returned, which is available from ConnectorOrchestrator 
and using *forConnector(this)* as a builder. 
*setRequestRouteTransformer(Consumer<RouteDefinition> requestRouteTransformer)* is for processing and transformation,
which occurs before providing the data to scenario, 
while *setResponseRouteTransformer(Consumer<RouteDefinition> responseRouteTransformer)* handles the response.
This is illustrated in the example below.

```java
@InboundConnector(
      connectorId = "appendStaticMessageProvider",
      connectorGroup = DemoConnectorGroup.ID,
      integrationScenario = DemoScenario.ID,
      requestModel = InboundConnectorRequest.class,
      responseModel = InboundConnectorResponse.class)
  public class DemoConnector extends GenericInboundConnectorBase {

    // Input endpoint
    @Override
    protected EndpointConsumerBuilder defineInitiatingEndpoint() {
      return StaticEndpointBuilders.direct("entry-point");
    }

    @Override
    protected Orchestrator<ConnectorOrchestrationInfo> defineTransformationOrchestrator() {
      return ConnectorOrchestrator.forConnector(this)
          .setRequestRouteTransformer(this::defineRequestRoute)
          .setResponseRouteTransformer(this::defineResponseRoute);
    }

    protected void defineRequestRoute(final RouteDefinition definition) {
      definition.process(exchange -> System.out.println("Processing and transformation pre-orchestration"));
    }

    protected void defineResponseRoute(final RouteDefinition definition) {
        definition.process(exchange -> System.out.println("Processing and transformation post-orchestration"));
    }
  }
```

**Rest connector**

Rest connectors are a subtype of inbound connectors. 
They are used in order to define REST inbound endpoint via Apache Camel RestDSL.
The difference is that they need to extend _RestConnectorBase_, but the annotation stays the same.

Unlike generic inbound connectors it is required to override *void configureRest(RestDefinition definition)* method 
and append the rest DSL to RestDefinition to define the input endpoint.

```java
 @InboundConnector(
      connectorGroup = DemoConnectorGroup.ID,
      integrationScenario = RestDSLScenario.ID,
      requestModel = String.class)
  public class RestConnectorTestBase extends RestConnectorBase {

    // Input endpoint defined via Rest DSl
    @Override
    protected void configureRest(RestDefinition definition) {
      definition.post("user");
    }

    @Override
    protected Orchestrator<ConnectorOrchestrationInfo> defineTransformationOrchestrator() {
      return ConnectorOrchestrator.forConnector(this)
          .setRequestRouteTransformer(this::defineRequestRoute);
    }

    protected void defineRequestRoute(final RouteDefinition definition) {
        definition.process(exchange -> System.out.println("Processing and transformation pre-orchestration"));
    }
  }
```

**Outbound**

Outbound connectors are used to define communication with the external systems inside the adapter.
They need to extend _GenericOutboundConnectorBase_ and override necessary methods,
but also to be annotated with @OutboundConnector, with the following fields:

- *connectorId* (optional) - unique identifier of a connector (automatically generated if missing)
- *connectorGroup* - id of the connector group it belongs to
- *integrationScenario* - id of the scenario from which it consumes data
- *requestModel* - model which is expected to be received in the input endpoint from scenario
- *responseModel* (optional) - model which is expected be returned to the caller
- *domains* (optional) - domains this connector is a part of
- *pathToDocumentationResource* (optional) - provides path to documentation files.
  (By default it will look for file in _document/structure/connectors/{connectorId}.md_)

Same as inbound, the behaviour is defined through overridden method implementation.

*EndpointProducerBuilder defineOutgoingEndpoint()* is used to define the endpoint, 
which executes the call to an external system.
StaticEndpointBuilders can be used to provide the endpoint definition. **Apache Camel** is used in the Outbound endpoints as well.

Defining processing and transformation is done in *Orchestrator<ConnectorOrchestrationInfo> defineTransformationOrchestrator()*.
Here an Orchestrator needs to be returned, which is available from ConnectorOrchestrator
and using *forConnector(this)* as a builder.
*setRequestRouteTransformer(Consumer<RouteDefinition> requestRouteTransformer)* is for processing and transformation,
which occurs before external system call,
while *setResponseRouteTransformer(Consumer<RouteDefinition> responseRouteTransformer)* handles the response.
This is illustrated in the example below.

```java
@OutboundConnector(
      connectorGroup = OtherDemoGroup.ID,
      integrationScenario = DemoScenario.ID,
      requestModel = OutboundConnectorRequest.class,
      responseModel = OutboundConnectorResponse.class)
  public class DemoOutboundConnector extends GenericOutboundConnectorBase {

    // external endpoint definition
    @Override
    protected EndpointProducerBuilder defineOutgoingEndpoint() {
      return StaticEndpointBuilders.http("localhost:8080/update");
    }

    @Override
    protected Orchestrator<ConnectorOrchestrationInfo> defineTransformationOrchestrator() {
      return ConnectorOrchestrator.forConnector(this)
          .setRequestRouteTransformer(this::defineRequestRoute)
          .setResponseRouteTransformer(this::defineResponseRoute);
    }

    protected void defineRequestRoute(final RouteDefinition definition) {
        definition.process(exchange -> System.out.println("Processing and transformation before external system call"));
    }

    protected void defineResponseRoute(final RouteDefinition definition) {
        definition.process(exchange -> System.out.println("Processing and transformation after external system call"));
    }
  }
```

### Composite Processes

Similar procedure should be followed as on the other declarative elements.
We first need to extend CompositeProcessBase.
Then, annotate the class with @CompositeProcess and fill in the required fields:

- *processId* - unique identifier of a process, used to identify it in SIP, should be unique
- *provider* - represents the integration scenario that provides the data to the process
- *consumers* (array) - represents integration scenarios that consume data from the process
- *pathToDocumentationResource* (optional) - provides path to process documentation files
  (By default it will look for file in _document/structure/processes/<composite-process-id>.md_)

```java
  @CompositeProcess(processId = "demo-process", consumers = {DemoScenarioConsumer1.class, DemoScenarioConsumer2.class},
        provider = DemoScenario.class)  
  public class DemoProcess extends CompositeProcessBase {
    public static final String ID = "demo-process";
  }
```

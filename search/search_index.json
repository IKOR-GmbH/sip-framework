{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"System Integration Platform Framework \u00b6 The System Integration Platform (SIP) Framework is an IKOR product developed from 10 project years of experience with standardized integration of core and peripheral systems. The framework enables building light-weight integration adapters to achieve a technical and non-technical decoupling of systems, using microservices and is therefore highly scalable. It builds on Apache Camel Framework and extends it with a lot of usable features to create a standardized integration approach for all adapters. System Integration Platform Framework What is SIP Usage Framework components Framework features Getting started How and why to use SIP Middle Component Adding additional Camel starters to the project Adding new System Connectors Development Tips Configuration properties What is SIP \u00b6 S ystem I ntegration P latform is a combination of SIP framework, SIP management application and various implementation guidelines and best practices. Combined they create an advantage when developing microservice integration adapters. SIP adapters are specially designed as middleware integrators of specific subdomains of an enterprise. SIP project structure and implementation guidelines provide higher degree of code consistency across different adapter instances, making them much easier to maintain, manage and monitor. The goal is to have minimal set of restrictions of developer's freedom with maximum comfort and efficiency while developing. To start developing with SIP, we should first get familiar with its basic concepts. Let's take a very simple scenario as an example. Say we have two systems working on the same domain (Partner, Policy, Billing etc.), but they were never designed to work together, and suddenly there is a need to connect them. Both systems expose APIs, which are mutually not compatible, both by data model and/or communication technology they use. SIP is designed as a standalone middleware app with a sole purpose to resolve exactly this kind of problems in a flexible and standardized way. Actual integration scenarios may include more than two APIs, or even more than two systems, but all the principles apply equally to such scenarios. The image below shows the modules structure of a single SIP adapter. To provide a level of flexibility, SIP splits the problem into two, giving the possibility to develop and/or deploy connectors for individual systems separately. The integration logic is divided into three modules: System A - Connector , System B - Connector and Domain . The fourth module is the Application module. Its purpose is to converge the three integration modules into one deployable and executable application. The blue arrows represent dependencies of the application module. Domain The Domain module takes a central position in the image, because it provides the common data model for both systems. Also, it separates the system connectors from each other to allow loose coupling between them. It should not contain any integration logic but only simple Java objects representing the respective domain in which the system connectors of an adapter operate. All connectors should adapt the data models of their systems to or from this common model, depending on data flow, due to their incompatibilities. The domain can be seen as a kind of contract between the different system connectors which ensures that they can communicate with each other. It contains common data model which uniforms the data models from all integration sides. Connectors Connectors are designed to communicate with the associated external systems, thus all classes found in a connector should only relate to their integration side. To enable this, their local domain objects are aligned with the API of an external systems they communicate with. In order to send a message from one system connector to another, the local domain objects must be mapped to the shared domain object. Furthermore, this means that a message from system A is mapped to the shared domain object and then from the shared domain object to the model of system B and vice versa, due to their bidirectional nature. Notice the blue arrows pointing from the system connectors to the domain module, meaning that connectors are absolutely independent of each other. A developer can work on or deploy only one side, without the others being affected. This also means that changes on one of adapter's connector does not necessarily require changes of the other. That's especially important if the affected connector is reused across multiple adapters. In the picture domain A and domain B packages are shown optionally, together with corresponding mapper component, since integrated systems use the same communication data model sometimes. Each connector will have the following structure: config a place for any configuration classes sink here we should define Camel routes transformers it should contain classes for adapting the connector model to common domain model. domain (optional) it may contain the data model of the system. Application The Application module gathers all connector modules as one system and run them together. Starting your adapter is done by running SIPApplication class in the application module. Furthermore, its pom.xml must contain dependencies to all connector modules in adapter, in order to start them. This module should not contain any integration logic, but it's a good place for implementing Spring integration tests, such as default SIPApplicationTest, provided by archetype. Usage \u00b6 Framework components \u00b6 sip-archetype - Archetype creates a basic SIP Adapter project with a defined structure and necessary dependencies. Project is created by executing single maven command. sip-core - Core project for base SIP functionalities. sip-middle-component - Custom Camel component used as abstracted connector between different integration sides. sip-integration-starter - Starter project adding necessary predefined dependencies for integration adapters. sip-starter-parent - This project takes care of versions for Spring Boot and Camel dependencies. sip-security - Security in SIP framework. sip-test-kit - Tool for integration testing. The following image displays how listed modules are utilized on SIP adapter where the up arrows represent inheritance, down arrows dependencies. Framework features \u00b6 Framework provides different features some of which are enabled by default. All the features are customizable and can be overwritten or turned off by configuration. More about how to use them you can find under the corresponding module's documentation. Actuator health check and metrics - Out-of-the-box health checks for HTTP(S), JMS and FTP, SFTP and FTPS endpoints. Working with routes in runtime - Dynamical changing routes lifecycle. Logging Translation - Translation of logging messages. Changing log level programmatically - Dynamical changing of log level. Exchange tracing - Tracing and storing exchanges on Camel Processor level. OpenAPI Descriptor - Built-in OpenAPI. SIP Middle component publish-subscribe - Multiple consumers on middle component. SIP Security - Includes SSL setup, base and x509 authentication SIP Test Kit - Provides ability to run integration tests inside SIP adapters, define mocks for endpoints and generate test reports. Getting started \u00b6 Before development, check the following Installation guide . Once you have your adapter you can do the following steps: Run mvn clean install Crate common Data Model inside domain module Add necessary dependencies to each module Add RouteBuilders inside \"sink\" package in connectors Add classes which transform system data models to or from common domain model in \"transformers\" package in connectors (if needed) Add any configuration classes for a specific system inside \"config\" package in connectors Add general integration configuration in application.yml found inside application module resources Run SIPApplication found inside application module After the application is up and running you can check SIP's management API under localhost:8080/swagger-ui.html How and why to use SIP Middle Component \u00b6 SIP Middle Component (sipmc) is a key concept of SIP Framework. As such it is used as a communication device between connectors. To make a clear distinction between connectors, the point of separation can be seen with sipmc. It marks the end or beginning of integration sides. Currently, sipmc works as either 1 to 1 connector or publish subscribe, based on the number of consumers, without any additional configuration. Adding additional Camel starters to the project \u00b6 The Maven dependency management techniques implemented in the SIP archetype give you the ability to easily add new camel-starter dependencies to integration adapters. Should you need additional Apache Camel Components in the project, it is enough to add their Spring Boot starter dependency, without version number - as it is managed in the parent Maven module of the SIP integration adapter. For instance, to add ArangoDb Camel component, it is enough to add the following dependency to the project: <dependency> <groupId>org.apache.camel.springboot</groupId> <artifactId>camel-arangodb-starter</artifactId> </dependency> The same stands for adding Spring Boot starters - as they are managed in the parent Maven module they too can be added without explicitly stating version numbers. As a matter of fact, the overall dependency management performed by the Spring Boot is in place in integration adapters too. However, if you need to use some third-party libraries - there are chances that you will be responsible for managing their versions in the application. It is important to add the required dependency to the corresponding connector module's pom. Only that way connector modules can keep their independence. Adding new System Connectors \u00b6 By using the SIP archetype to create a new SIP adapter, by default there are two system connectors, designed to make it more convenient to integrate systems. In case there are more than two systems, which need to be integrated, you need to add additional modules to the project structure. There are a number of ways to add new system connectors to a SIP adapter. These possibilities are explained in detail in the following part. Initially each system connector module has two dependencies. These are the domain module and the sip-integration-starter . Make sure to add these to your pom.xml dependencies list. Please observe this exemplary pom.xml to see how it should look like in a system connector module. The module structure usually looks like this: fancy-sip-adapter \u251c\u2500\u2500\u2500new-system-connector-module \u2502 \u251c\u2500\u2500\u2500src/main/java/<package-path> \u2502 \u2502 \u251c\u2500\u2500\u2500config \u2502 \u2502 \u251c\u2500\u2500\u2500sink \u2502 \u2502 \u2514\u2500\u2500\u2500transformer \u2502 \u2514\u2500\u2500\u2500pom.xml ... Copying Existing Module One way to add a system connector as a new module is to copy an existing module, that has been created by using the SIP archetype to your project structure. If the module was copied the name and artifactId in its pom.xml need to be adjusted. Then the module name should be added to the modules element of the pom.xml of the main project. <modules> <module>system-connector-A</module> <module>system-connector-B</module> <module>new-system-connector-module</module> </modules> Additionally, the copied module must be added as a dependency to the pom.xml of the application module. <dependencies> <dependency> <groupId>de.ikor.sip.adapter</groupId> <artifactId>new-system-connector-module</artifactId> <version>${project.version}</version> </dependency> ... </dependencies> If necessary, refresh or rebuild the project so that the newly created module gets registered. Using IDEs Built-In Functionality IntelliJ Right click on the parent project folder and select New > Module... . Select Maven in the left menu and click on the Next button Provide a new module name and click on Finish Eclipse File > New > Other... Enter maven module select Maven Module from the search result list and click on Next Enter a module name select the parent project and press Next Choose a maven archetype version from the list and click Next (You can use the default selection) Check the archetype parameters and press Finish The result is a new subdirectory of the SIP adapter project. Compare the pom.xml of the newly created module with one of the modules that were created by SIP archetype. There are only a few differences that need to be adjusted. Make sure the newly created module is present in the modules element list of the main pom.xml and that it has been added as a dependency to the application pom.xml . Example POM <?xml version=\"1.0\" encoding=\"UTF-8\"?> <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"> <modelVersion>4.0.0</modelVersion> <parent> <groupId>de.ikor.sip.adapter</groupId> <artifactId>systemadapter</artifactId> <version>1.0-SNAPSHOT</version> </parent> <artifactId>outbound</artifactId> <name>outbound</name> <dependencies> <dependency> <groupId>de.ikor.sip.foundation</groupId> <artifactId>sip-integration-starter</artifactId> </dependency> <dependency> <groupId>de.ikor.sip.adapter</groupId> <artifactId>systemadapter-domain</artifactId> </dependency> </dependencies> </project> Development Tips \u00b6 Endpoint Configuration When it comes to working with URIs in routes, it is recommended to use property placeholders, which makes the routes configurable. Additionally, it would make much sense to follow suggested configuration convention for defining endpoint configuration. endpoint: <in/out>: <external-system>: <endpoint>: # optional - if more endpoints on single external-system are involved in integration id: <externalSystem> uri: ftp://... <in/out> corresponds to consumers and producers respectively. This means in case a message is received through a route using \"from\", then it is a consumer and \"in\" is used. On the other hand, it is a producer when a message is sent via \"to\". In this case, \"out\" is used as key in the configuration file. <external-system> should match the name of the system or client the adapter is communicating with. <endpoint> in case there are multiple endpoints for an adapter that uses the same domain and external system, additional identification is required. For this purpose we use an additional endpoint key to provide distinction. For example: endpoint: in: my-assurance-co: id: my-assurance-co uri: ftp://... out: their-assurance-co: id: their-assurance-co uri: https://... Using this configuration can be easily achieved in Camel by following their placeholder syntax. Here's what the example from above would look like in the Camel route: from(\"{{endpoint.in.my-assurance-co.uri}}\") .id(\"{{endpoint.in.my-assurance-co.id}}\") .to(...); from(...) .process(...) .to(\"{{endpoint.out.their-assurance-co.uri}}\") .id(\"{{endpoint.out.their-assurance-co.id}}\") If this convention is followed in the configuration, it leads to a unified structure that makes it possible to identify at a single glance which systems are communicating with each other and which communication technologies are being used. It also makes routes more descriptive and adapters much easier to maintain. Setting processor and route IDs As we can see each external endpoint, definition is followed by explicit setting of id. Although it's not mandatory, doing so is highly recommended especially in case of outgoing endpoints. This will provide a reference of the external endpoints, which can be used for different functionalities, like mocking, custom health check or other functionalities that are yet to come. Notice that in case of incoming endpoints (those in \"from\" statement), following id refers to the routeId. Configuration properties \u00b6 By default, the following properties come as a part of SIP Framework, to override them simply add them to your configuration file with desired values. When using a yaml configuration file, which is already available in application module, adapt the properties to its format. Name Description Value Default sip.core.translation.fileLocations Sets locations of translation bundles List classpath:translations/translated-messages, classpath:translations/sip-core-messages sip.core.translation.default-encoding Sets default encoding String UTF-8 sip.core.translation.fallback-to-system-locale Use system language if none defined boolean false sip.core.translation.use-code-as-default-message If key is not assigned use it in message boolean true sip.core.translation.lang Set language of log messages String en sip.core.metrics.external-endpoint-health-check.enabled Enable health status calculation boolean true sip.core.metrics.external-endpoint-health-check.scheduler.fixed-delay Sets health check execution interval number 900000 sip.core.metrics.external-endpoint-health-check.scheduler.initial-delay Sets health check execution initial delay number 5000 sip.core.tracing.enabled Enable SIP tracing and trace history boolean true sip.core.tracing.limit Sets storage limit in trace history number 100 sip.core.tracing.trace-type Sets how tracer should behave String \"*\" sip.core.tracing.exchange-formatter.{property-name} Sets value for specific property in ExchangeFormatter / / sip.testkit.enabled Enables SIP Test Kit boolean true management.endpoint.health.show-details Enable health details in actuator String always management.endpoints.web.exposure.include Set which endpoints are included String health,info,metrics,loggers,prometheus springdoc.show-actuator Show actuator API in Swagger docs boolean true springdoc.api-docs.path Custom path to API docs String /api-docs springdoc.swagger-ui.path Custom path to Swagger String /swagger-ui.html springdoc.swagger-ui.disable-swagger-default-url Disables default petstore API in swagger boolean true springdoc.api-docs.enabled Enable/Disable API docs boolean true springdoc.swagger-ui.enabled Enable/Disable swagger boolean true logging.level.root Sets the default log level String INFO","title":"Introduction"},{"location":"#system-integration-platform-framework","text":"The System Integration Platform (SIP) Framework is an IKOR product developed from 10 project years of experience with standardized integration of core and peripheral systems. The framework enables building light-weight integration adapters to achieve a technical and non-technical decoupling of systems, using microservices and is therefore highly scalable. It builds on Apache Camel Framework and extends it with a lot of usable features to create a standardized integration approach for all adapters. System Integration Platform Framework What is SIP Usage Framework components Framework features Getting started How and why to use SIP Middle Component Adding additional Camel starters to the project Adding new System Connectors Development Tips Configuration properties","title":"System Integration Platform Framework"},{"location":"#what-is-sip","text":"S ystem I ntegration P latform is a combination of SIP framework, SIP management application and various implementation guidelines and best practices. Combined they create an advantage when developing microservice integration adapters. SIP adapters are specially designed as middleware integrators of specific subdomains of an enterprise. SIP project structure and implementation guidelines provide higher degree of code consistency across different adapter instances, making them much easier to maintain, manage and monitor. The goal is to have minimal set of restrictions of developer's freedom with maximum comfort and efficiency while developing. To start developing with SIP, we should first get familiar with its basic concepts. Let's take a very simple scenario as an example. Say we have two systems working on the same domain (Partner, Policy, Billing etc.), but they were never designed to work together, and suddenly there is a need to connect them. Both systems expose APIs, which are mutually not compatible, both by data model and/or communication technology they use. SIP is designed as a standalone middleware app with a sole purpose to resolve exactly this kind of problems in a flexible and standardized way. Actual integration scenarios may include more than two APIs, or even more than two systems, but all the principles apply equally to such scenarios. The image below shows the modules structure of a single SIP adapter. To provide a level of flexibility, SIP splits the problem into two, giving the possibility to develop and/or deploy connectors for individual systems separately. The integration logic is divided into three modules: System A - Connector , System B - Connector and Domain . The fourth module is the Application module. Its purpose is to converge the three integration modules into one deployable and executable application. The blue arrows represent dependencies of the application module. Domain The Domain module takes a central position in the image, because it provides the common data model for both systems. Also, it separates the system connectors from each other to allow loose coupling between them. It should not contain any integration logic but only simple Java objects representing the respective domain in which the system connectors of an adapter operate. All connectors should adapt the data models of their systems to or from this common model, depending on data flow, due to their incompatibilities. The domain can be seen as a kind of contract between the different system connectors which ensures that they can communicate with each other. It contains common data model which uniforms the data models from all integration sides. Connectors Connectors are designed to communicate with the associated external systems, thus all classes found in a connector should only relate to their integration side. To enable this, their local domain objects are aligned with the API of an external systems they communicate with. In order to send a message from one system connector to another, the local domain objects must be mapped to the shared domain object. Furthermore, this means that a message from system A is mapped to the shared domain object and then from the shared domain object to the model of system B and vice versa, due to their bidirectional nature. Notice the blue arrows pointing from the system connectors to the domain module, meaning that connectors are absolutely independent of each other. A developer can work on or deploy only one side, without the others being affected. This also means that changes on one of adapter's connector does not necessarily require changes of the other. That's especially important if the affected connector is reused across multiple adapters. In the picture domain A and domain B packages are shown optionally, together with corresponding mapper component, since integrated systems use the same communication data model sometimes. Each connector will have the following structure: config a place for any configuration classes sink here we should define Camel routes transformers it should contain classes for adapting the connector model to common domain model. domain (optional) it may contain the data model of the system. Application The Application module gathers all connector modules as one system and run them together. Starting your adapter is done by running SIPApplication class in the application module. Furthermore, its pom.xml must contain dependencies to all connector modules in adapter, in order to start them. This module should not contain any integration logic, but it's a good place for implementing Spring integration tests, such as default SIPApplicationTest, provided by archetype.","title":"What is SIP"},{"location":"#usage","text":"","title":"Usage"},{"location":"#framework-components","text":"sip-archetype - Archetype creates a basic SIP Adapter project with a defined structure and necessary dependencies. Project is created by executing single maven command. sip-core - Core project for base SIP functionalities. sip-middle-component - Custom Camel component used as abstracted connector between different integration sides. sip-integration-starter - Starter project adding necessary predefined dependencies for integration adapters. sip-starter-parent - This project takes care of versions for Spring Boot and Camel dependencies. sip-security - Security in SIP framework. sip-test-kit - Tool for integration testing. The following image displays how listed modules are utilized on SIP adapter where the up arrows represent inheritance, down arrows dependencies.","title":"Framework components"},{"location":"#framework-features","text":"Framework provides different features some of which are enabled by default. All the features are customizable and can be overwritten or turned off by configuration. More about how to use them you can find under the corresponding module's documentation. Actuator health check and metrics - Out-of-the-box health checks for HTTP(S), JMS and FTP, SFTP and FTPS endpoints. Working with routes in runtime - Dynamical changing routes lifecycle. Logging Translation - Translation of logging messages. Changing log level programmatically - Dynamical changing of log level. Exchange tracing - Tracing and storing exchanges on Camel Processor level. OpenAPI Descriptor - Built-in OpenAPI. SIP Middle component publish-subscribe - Multiple consumers on middle component. SIP Security - Includes SSL setup, base and x509 authentication SIP Test Kit - Provides ability to run integration tests inside SIP adapters, define mocks for endpoints and generate test reports.","title":"Framework features"},{"location":"#getting-started","text":"Before development, check the following Installation guide . Once you have your adapter you can do the following steps: Run mvn clean install Crate common Data Model inside domain module Add necessary dependencies to each module Add RouteBuilders inside \"sink\" package in connectors Add classes which transform system data models to or from common domain model in \"transformers\" package in connectors (if needed) Add any configuration classes for a specific system inside \"config\" package in connectors Add general integration configuration in application.yml found inside application module resources Run SIPApplication found inside application module After the application is up and running you can check SIP's management API under localhost:8080/swagger-ui.html","title":"Getting started"},{"location":"#how-and-why-to-use-sip-middle-component","text":"SIP Middle Component (sipmc) is a key concept of SIP Framework. As such it is used as a communication device between connectors. To make a clear distinction between connectors, the point of separation can be seen with sipmc. It marks the end or beginning of integration sides. Currently, sipmc works as either 1 to 1 connector or publish subscribe, based on the number of consumers, without any additional configuration.","title":"How and why to use SIP Middle Component"},{"location":"#adding-additional-camel-starters-to-the-project","text":"The Maven dependency management techniques implemented in the SIP archetype give you the ability to easily add new camel-starter dependencies to integration adapters. Should you need additional Apache Camel Components in the project, it is enough to add their Spring Boot starter dependency, without version number - as it is managed in the parent Maven module of the SIP integration adapter. For instance, to add ArangoDb Camel component, it is enough to add the following dependency to the project: <dependency> <groupId>org.apache.camel.springboot</groupId> <artifactId>camel-arangodb-starter</artifactId> </dependency> The same stands for adding Spring Boot starters - as they are managed in the parent Maven module they too can be added without explicitly stating version numbers. As a matter of fact, the overall dependency management performed by the Spring Boot is in place in integration adapters too. However, if you need to use some third-party libraries - there are chances that you will be responsible for managing their versions in the application. It is important to add the required dependency to the corresponding connector module's pom. Only that way connector modules can keep their independence.","title":"Adding additional Camel starters to the project"},{"location":"#adding-new-system-connectors","text":"By using the SIP archetype to create a new SIP adapter, by default there are two system connectors, designed to make it more convenient to integrate systems. In case there are more than two systems, which need to be integrated, you need to add additional modules to the project structure. There are a number of ways to add new system connectors to a SIP adapter. These possibilities are explained in detail in the following part. Initially each system connector module has two dependencies. These are the domain module and the sip-integration-starter . Make sure to add these to your pom.xml dependencies list. Please observe this exemplary pom.xml to see how it should look like in a system connector module. The module structure usually looks like this: fancy-sip-adapter \u251c\u2500\u2500\u2500new-system-connector-module \u2502 \u251c\u2500\u2500\u2500src/main/java/<package-path> \u2502 \u2502 \u251c\u2500\u2500\u2500config \u2502 \u2502 \u251c\u2500\u2500\u2500sink \u2502 \u2502 \u2514\u2500\u2500\u2500transformer \u2502 \u2514\u2500\u2500\u2500pom.xml ... Copying Existing Module One way to add a system connector as a new module is to copy an existing module, that has been created by using the SIP archetype to your project structure. If the module was copied the name and artifactId in its pom.xml need to be adjusted. Then the module name should be added to the modules element of the pom.xml of the main project. <modules> <module>system-connector-A</module> <module>system-connector-B</module> <module>new-system-connector-module</module> </modules> Additionally, the copied module must be added as a dependency to the pom.xml of the application module. <dependencies> <dependency> <groupId>de.ikor.sip.adapter</groupId> <artifactId>new-system-connector-module</artifactId> <version>${project.version}</version> </dependency> ... </dependencies> If necessary, refresh or rebuild the project so that the newly created module gets registered. Using IDEs Built-In Functionality IntelliJ Right click on the parent project folder and select New > Module... . Select Maven in the left menu and click on the Next button Provide a new module name and click on Finish Eclipse File > New > Other... Enter maven module select Maven Module from the search result list and click on Next Enter a module name select the parent project and press Next Choose a maven archetype version from the list and click Next (You can use the default selection) Check the archetype parameters and press Finish The result is a new subdirectory of the SIP adapter project. Compare the pom.xml of the newly created module with one of the modules that were created by SIP archetype. There are only a few differences that need to be adjusted. Make sure the newly created module is present in the modules element list of the main pom.xml and that it has been added as a dependency to the application pom.xml . Example POM <?xml version=\"1.0\" encoding=\"UTF-8\"?> <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"> <modelVersion>4.0.0</modelVersion> <parent> <groupId>de.ikor.sip.adapter</groupId> <artifactId>systemadapter</artifactId> <version>1.0-SNAPSHOT</version> </parent> <artifactId>outbound</artifactId> <name>outbound</name> <dependencies> <dependency> <groupId>de.ikor.sip.foundation</groupId> <artifactId>sip-integration-starter</artifactId> </dependency> <dependency> <groupId>de.ikor.sip.adapter</groupId> <artifactId>systemadapter-domain</artifactId> </dependency> </dependencies> </project>","title":"Adding new System Connectors"},{"location":"#development-tips","text":"Endpoint Configuration When it comes to working with URIs in routes, it is recommended to use property placeholders, which makes the routes configurable. Additionally, it would make much sense to follow suggested configuration convention for defining endpoint configuration. endpoint: <in/out>: <external-system>: <endpoint>: # optional - if more endpoints on single external-system are involved in integration id: <externalSystem> uri: ftp://... <in/out> corresponds to consumers and producers respectively. This means in case a message is received through a route using \"from\", then it is a consumer and \"in\" is used. On the other hand, it is a producer when a message is sent via \"to\". In this case, \"out\" is used as key in the configuration file. <external-system> should match the name of the system or client the adapter is communicating with. <endpoint> in case there are multiple endpoints for an adapter that uses the same domain and external system, additional identification is required. For this purpose we use an additional endpoint key to provide distinction. For example: endpoint: in: my-assurance-co: id: my-assurance-co uri: ftp://... out: their-assurance-co: id: their-assurance-co uri: https://... Using this configuration can be easily achieved in Camel by following their placeholder syntax. Here's what the example from above would look like in the Camel route: from(\"{{endpoint.in.my-assurance-co.uri}}\") .id(\"{{endpoint.in.my-assurance-co.id}}\") .to(...); from(...) .process(...) .to(\"{{endpoint.out.their-assurance-co.uri}}\") .id(\"{{endpoint.out.their-assurance-co.id}}\") If this convention is followed in the configuration, it leads to a unified structure that makes it possible to identify at a single glance which systems are communicating with each other and which communication technologies are being used. It also makes routes more descriptive and adapters much easier to maintain. Setting processor and route IDs As we can see each external endpoint, definition is followed by explicit setting of id. Although it's not mandatory, doing so is highly recommended especially in case of outgoing endpoints. This will provide a reference of the external endpoints, which can be used for different functionalities, like mocking, custom health check or other functionalities that are yet to come. Notice that in case of incoming endpoints (those in \"from\" statement), following id refers to the routeId.","title":"Development Tips"},{"location":"#configuration-properties","text":"By default, the following properties come as a part of SIP Framework, to override them simply add them to your configuration file with desired values. When using a yaml configuration file, which is already available in application module, adapt the properties to its format. Name Description Value Default sip.core.translation.fileLocations Sets locations of translation bundles List classpath:translations/translated-messages, classpath:translations/sip-core-messages sip.core.translation.default-encoding Sets default encoding String UTF-8 sip.core.translation.fallback-to-system-locale Use system language if none defined boolean false sip.core.translation.use-code-as-default-message If key is not assigned use it in message boolean true sip.core.translation.lang Set language of log messages String en sip.core.metrics.external-endpoint-health-check.enabled Enable health status calculation boolean true sip.core.metrics.external-endpoint-health-check.scheduler.fixed-delay Sets health check execution interval number 900000 sip.core.metrics.external-endpoint-health-check.scheduler.initial-delay Sets health check execution initial delay number 5000 sip.core.tracing.enabled Enable SIP tracing and trace history boolean true sip.core.tracing.limit Sets storage limit in trace history number 100 sip.core.tracing.trace-type Sets how tracer should behave String \"*\" sip.core.tracing.exchange-formatter.{property-name} Sets value for specific property in ExchangeFormatter / / sip.testkit.enabled Enables SIP Test Kit boolean true management.endpoint.health.show-details Enable health details in actuator String always management.endpoints.web.exposure.include Set which endpoints are included String health,info,metrics,loggers,prometheus springdoc.show-actuator Show actuator API in Swagger docs boolean true springdoc.api-docs.path Custom path to API docs String /api-docs springdoc.swagger-ui.path Custom path to Swagger String /swagger-ui.html springdoc.swagger-ui.disable-swagger-default-url Disables default petstore API in swagger boolean true springdoc.api-docs.enabled Enable/Disable API docs boolean true springdoc.swagger-ui.enabled Enable/Disable swagger boolean true logging.level.root Sets the default log level String INFO","title":"Configuration properties"},{"location":"CODE_OF_CONDUCT/","text":"Contributor Code of Conduct \u00b6 As contributors and maintainers of this project, and in the interest of fostering an open and welcoming community, we pledge to respect all people who contribute through reporting issues, posting feature requests, updating documentation, submitting pull requests or patches, and other activities. We are committed to making participation in this project a harassment-free experience for everyone, regardless of level of experience, gender, gender identity and expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion, or nationality. Examples of unacceptable behavior by participants include: The use of sexualized language or imagery Personal attacks Trolling or insulting/derogatory comments Public or private harassment Publishing other's private information, such as physical or electronic addresses, without explicit permission Other unethical or unprofessional conduct Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. By adopting this Code of Conduct, project maintainers commit themselves to fairly and consistently applying these principles to every aspect of managing this project. Project maintainers who do not follow or enforce the Code of Conduct may be permanently removed from the project team. This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting a project maintainer at code-of-conduct@ikor.de. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. Maintainers are obligated to maintain confidentiality with regard to the reporter of an incident. This Code of Conduct is adapted from the Contributor Covenant , version 1.3.0, available at contributor-covenant.org/version/1/3/0/","title":"Code Of Conduct"},{"location":"CODE_OF_CONDUCT/#contributor-code-of-conduct","text":"As contributors and maintainers of this project, and in the interest of fostering an open and welcoming community, we pledge to respect all people who contribute through reporting issues, posting feature requests, updating documentation, submitting pull requests or patches, and other activities. We are committed to making participation in this project a harassment-free experience for everyone, regardless of level of experience, gender, gender identity and expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion, or nationality. Examples of unacceptable behavior by participants include: The use of sexualized language or imagery Personal attacks Trolling or insulting/derogatory comments Public or private harassment Publishing other's private information, such as physical or electronic addresses, without explicit permission Other unethical or unprofessional conduct Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. By adopting this Code of Conduct, project maintainers commit themselves to fairly and consistently applying these principles to every aspect of managing this project. Project maintainers who do not follow or enforce the Code of Conduct may be permanently removed from the project team. This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting a project maintainer at code-of-conduct@ikor.de. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. Maintainers are obligated to maintain confidentiality with regard to the reporter of an incident. This Code of Conduct is adapted from the Contributor Covenant , version 1.3.0, available at contributor-covenant.org/version/1/3/0/","title":"Contributor Code of Conduct"},{"location":"CONTRIBUTING/","text":"Contributing to SIP \u00b6 Contributing to SIP Code of conduct How can I contribute Reporting bugs Reporting security vulnerabilities Requesting features Pull requests (to get YOUR contribution merged) Guidelines Coding Pull request process First off, thanks for your contribution! \ud83d\udc4d SIP is released under the Apache 2.0 license. If you would like to contribute you are very welcome to do so and this document should help you having a good start. Please note we have a code of conduct, please follow it in all your interactions with the project. Code of conduct \u00b6 This project adheres to the Contributor Covenant code of conduct . By participating, you are expected to uphold this code. Please report unacceptable behavior to the given email address. How can I contribute \u00b6 Reporting bugs \u00b6 We use GitHub issues to track bugs. Bug reports should be done by using and completing the bug tracking template. Please handle possibly security vulnerabilities with special care as described below. Reporting security vulnerabilities \u00b6 If you think you have found a security vulnerability please DO NOT disclose it publicly until we've had a chance to fix it as this may result in an unnecessary security threat. We will handle these requests with special care. Please contact us with templated bug report via email at: opensource@ikor.de Requesting features \u00b6 Feature requests can be done by creating a Github Issue using the feature request template. Pull requests (to get YOUR contribution merged) \u00b6 Another option to contribute is to fix any bugs from the bug list, implement features, extend functionality, adapt the documentation or whatever else you can imagine! \ud83d\udc4d To get your adaptions merged you need to create a pull request. You have to complete the provided pull request template. We will take care of the submitted pull requests and to mention this once again: Thank you very much for your contribution! Guidelines \u00b6 We welcome everyones work and engagement to evolve SIP. To make our life easier and we defined a couple of guidelines to follow while working on the code and we ask everyone to adhere to these points. During the pull request process the reviewer will check if the pull request adheres to the following rules. The rules are questions you should answer before creating a pull request: Coding \u00b6 Have you avoided to use field based autowiring? (see here why we chose to use constructor autowiring) Are all your unit tests written with junit5 and assertions with assertj ( see )? Does your code not add any new compile warnings? Does your contribution contain necessary and useful javadoc and is the linting process successful? Is the maven project version a SNAPSHOT version? Are all dependencies you added RELEASE versions? Did you change something in the documentation? Then run ./run-mkdocs-server.sh and check that your changes look good (mkdocs server will be running on port 8000) Pull request process \u00b6 Does your contribution follow the Google Java Coding style? (you can find it here ) Does your pull request only contain changes related to the topic the branch was intended for? Does your pull request contain useful and necessary tests? Was the Sonarqube analysis of your PR successful and all quality gates are met? Have you added a complete, valid and self explaining changelog? Changelogs have to be put into one of these folders: changelogs/bugfix , changelogs/documentation , changelogs/feature , changelogs/major The name of the changelog file has to end with the suffix .json The format of a changelog file is as follow (don't copy the comments, only the real json key-value pairs): { # put your github username here \"author\": \"stieglma\", # put the id of the pull request here (yes that means you will need to create the pull # request before you can finish writing the changelog entry) \"pullrequestId\": 1, # put a precise and short description of your changes here \"message\": \"Update documentation, add information about changelog entries for contributors\", # issue id is optional, there may be pull requests without related issues, # so this field can be left out if necessary \"issue\": \"123\" } Is your pull request mergeable? Was your branch deleted after merging the sources? Does the pull request also contain necessary documentation changes or adaptions Have you used and completed the pull request form provided?","title":"Contribution Guidelines"},{"location":"CONTRIBUTING/#contributing-to-sip","text":"Contributing to SIP Code of conduct How can I contribute Reporting bugs Reporting security vulnerabilities Requesting features Pull requests (to get YOUR contribution merged) Guidelines Coding Pull request process First off, thanks for your contribution! \ud83d\udc4d SIP is released under the Apache 2.0 license. If you would like to contribute you are very welcome to do so and this document should help you having a good start. Please note we have a code of conduct, please follow it in all your interactions with the project.","title":"Contributing to SIP"},{"location":"CONTRIBUTING/#code-of-conduct","text":"This project adheres to the Contributor Covenant code of conduct . By participating, you are expected to uphold this code. Please report unacceptable behavior to the given email address.","title":"Code of conduct"},{"location":"CONTRIBUTING/#how-can-i-contribute","text":"","title":"How can I contribute"},{"location":"CONTRIBUTING/#reporting-bugs","text":"We use GitHub issues to track bugs. Bug reports should be done by using and completing the bug tracking template. Please handle possibly security vulnerabilities with special care as described below.","title":"Reporting bugs"},{"location":"CONTRIBUTING/#reporting-security-vulnerabilities","text":"If you think you have found a security vulnerability please DO NOT disclose it publicly until we've had a chance to fix it as this may result in an unnecessary security threat. We will handle these requests with special care. Please contact us with templated bug report via email at: opensource@ikor.de","title":"Reporting security vulnerabilities"},{"location":"CONTRIBUTING/#requesting-features","text":"Feature requests can be done by creating a Github Issue using the feature request template.","title":"Requesting features"},{"location":"CONTRIBUTING/#pull-requests-to-get-your-contribution-merged","text":"Another option to contribute is to fix any bugs from the bug list, implement features, extend functionality, adapt the documentation or whatever else you can imagine! \ud83d\udc4d To get your adaptions merged you need to create a pull request. You have to complete the provided pull request template. We will take care of the submitted pull requests and to mention this once again: Thank you very much for your contribution!","title":"Pull requests (to get YOUR contribution merged)"},{"location":"CONTRIBUTING/#guidelines","text":"We welcome everyones work and engagement to evolve SIP. To make our life easier and we defined a couple of guidelines to follow while working on the code and we ask everyone to adhere to these points. During the pull request process the reviewer will check if the pull request adheres to the following rules. The rules are questions you should answer before creating a pull request:","title":"Guidelines"},{"location":"CONTRIBUTING/#coding","text":"Have you avoided to use field based autowiring? (see here why we chose to use constructor autowiring) Are all your unit tests written with junit5 and assertions with assertj ( see )? Does your code not add any new compile warnings? Does your contribution contain necessary and useful javadoc and is the linting process successful? Is the maven project version a SNAPSHOT version? Are all dependencies you added RELEASE versions? Did you change something in the documentation? Then run ./run-mkdocs-server.sh and check that your changes look good (mkdocs server will be running on port 8000)","title":"Coding"},{"location":"CONTRIBUTING/#pull-request-process","text":"Does your contribution follow the Google Java Coding style? (you can find it here ) Does your pull request only contain changes related to the topic the branch was intended for? Does your pull request contain useful and necessary tests? Was the Sonarqube analysis of your PR successful and all quality gates are met? Have you added a complete, valid and self explaining changelog? Changelogs have to be put into one of these folders: changelogs/bugfix , changelogs/documentation , changelogs/feature , changelogs/major The name of the changelog file has to end with the suffix .json The format of a changelog file is as follow (don't copy the comments, only the real json key-value pairs): { # put your github username here \"author\": \"stieglma\", # put the id of the pull request here (yes that means you will need to create the pull # request before you can finish writing the changelog entry) \"pullrequestId\": 1, # put a precise and short description of your changes here \"message\": \"Update documentation, add information about changelog entries for contributors\", # issue id is optional, there may be pull requests without related issues, # so this field can be left out if necessary \"issue\": \"123\" } Is your pull request mergeable? Was your branch deleted after merging the sources? Does the pull request also contain necessary documentation changes or adaptions Have you used and completed the pull request form provided?","title":"Pull request process"},{"location":"archetype/","text":"IKOR SIP Archetype \u00b6 IKOR SIP Archetype Description How to create a SIP Adapter using SIP Archetype Description \u00b6 This archetype creates a basic SIP Adapter project with a defined structure and necessary dependencies How to create a SIP Adapter using SIP Archetype \u00b6 In order to make setting up a new integration adapter project an easy task, we have created a dedicated SIP (Adapter) Maven archetype, that gives the ability to quickly bootstrap a new integration adapter, along with all needed Maven dependencies and goodies, as well as the recommended, preferred organization of the project. To make a long story short, you can create a SIP Adapter by using the following Maven command: Mac OS mvn archetype:generate \\ -DarchetypeGroupId=de.ikor.sip.foundation \\ -DarchetypeArtifactId=sip-archetype \\ -DarchetypeVersion=<latest.sip-archetype.version> \\ -DgroupId=de.ikor.sip.adapter \\ -DartifactId=demo \\ -DprojectName=DemoAdapter \\ -Dversion=1.0.0-SNAPSHOT Windows OS mvn archetype:generate ^ -DarchetypeGroupId=de.ikor.sip.foundation ^ -DarchetypeArtifactId=sip-archetype ^ -DarchetypeVersion=<latest.sip-archetype.version> ^ -DgroupId=de.ikor.sip.adapter ^ -DartifactId=demo ^ -DprojectName=DemoAdapter ^ -Dversion=1.0.0-SNAPSHOT When executing the command, pay attention to use the latest archetype version for the -DarchetypeVersion parameter. The parameters -DgroupId , -DartifactId , -DprojectName and -Dversion should be adjusted to better match your project, as they set the properties for the adapter. It is recommended to follow the maven naming convention. After executing maven command, you will be requested to insert additional parameters about project structure: packageSuffix is used to create project package name by concatenating its value to the groupId. There is a strict validation for using only lower case letters and it is meant to name the package by extending your groupId for only one word. package (optional) is used to override previous package naming and provide full package name. This can be skipped by leaving value empty. It is strongly recommended to follow package naming convention, otherwise your project will be created but it will consist package naming errors. systemConnector1 / systemConnector2 are representing names of your connector modules inside the project. Naming recommendation is to use lower case letters and kebab-case. systemConnector1Package / systemConnector2Package are used to define package name suffix for the connectors. Notice that connector package name starts with prefix defined on package step. useLombokDefault / useLombok are properties used for including or excluding Lombok dependency in adapter. Parameter useLombokDefault is only used to include lombok by default. If you wish to exclude lombok you should set useLombok to anything other than 'y' or 'Y'. After a successful build, a project with the 4 following modules will be created: {artifactId}-application {artifactId}-domain {systemConnector1} {systemConnector2} Our recommendation for modules naming is shown on the following Partner Adapter example: partner-adapter-application partner-adapter-domain partner-connector-{arbitrary connector1 name} partner-connector-{arbitrary connector2 name} More about modules and internal SIP structure you can find here . More information about Maven archetypes is available here: Maven Archetype","title":"Archetype"},{"location":"archetype/#ikor-sip-archetype","text":"IKOR SIP Archetype Description How to create a SIP Adapter using SIP Archetype","title":"IKOR SIP Archetype"},{"location":"archetype/#description","text":"This archetype creates a basic SIP Adapter project with a defined structure and necessary dependencies","title":"Description"},{"location":"archetype/#how-to-create-a-sip-adapter-using-sip-archetype","text":"In order to make setting up a new integration adapter project an easy task, we have created a dedicated SIP (Adapter) Maven archetype, that gives the ability to quickly bootstrap a new integration adapter, along with all needed Maven dependencies and goodies, as well as the recommended, preferred organization of the project. To make a long story short, you can create a SIP Adapter by using the following Maven command: Mac OS mvn archetype:generate \\ -DarchetypeGroupId=de.ikor.sip.foundation \\ -DarchetypeArtifactId=sip-archetype \\ -DarchetypeVersion=<latest.sip-archetype.version> \\ -DgroupId=de.ikor.sip.adapter \\ -DartifactId=demo \\ -DprojectName=DemoAdapter \\ -Dversion=1.0.0-SNAPSHOT Windows OS mvn archetype:generate ^ -DarchetypeGroupId=de.ikor.sip.foundation ^ -DarchetypeArtifactId=sip-archetype ^ -DarchetypeVersion=<latest.sip-archetype.version> ^ -DgroupId=de.ikor.sip.adapter ^ -DartifactId=demo ^ -DprojectName=DemoAdapter ^ -Dversion=1.0.0-SNAPSHOT When executing the command, pay attention to use the latest archetype version for the -DarchetypeVersion parameter. The parameters -DgroupId , -DartifactId , -DprojectName and -Dversion should be adjusted to better match your project, as they set the properties for the adapter. It is recommended to follow the maven naming convention. After executing maven command, you will be requested to insert additional parameters about project structure: packageSuffix is used to create project package name by concatenating its value to the groupId. There is a strict validation for using only lower case letters and it is meant to name the package by extending your groupId for only one word. package (optional) is used to override previous package naming and provide full package name. This can be skipped by leaving value empty. It is strongly recommended to follow package naming convention, otherwise your project will be created but it will consist package naming errors. systemConnector1 / systemConnector2 are representing names of your connector modules inside the project. Naming recommendation is to use lower case letters and kebab-case. systemConnector1Package / systemConnector2Package are used to define package name suffix for the connectors. Notice that connector package name starts with prefix defined on package step. useLombokDefault / useLombok are properties used for including or excluding Lombok dependency in adapter. Parameter useLombokDefault is only used to include lombok by default. If you wish to exclude lombok you should set useLombok to anything other than 'y' or 'Y'. After a successful build, a project with the 4 following modules will be created: {artifactId}-application {artifactId}-domain {systemConnector1} {systemConnector2} Our recommendation for modules naming is shown on the following Partner Adapter example: partner-adapter-application partner-adapter-domain partner-connector-{arbitrary connector1 name} partner-connector-{arbitrary connector2 name} More about modules and internal SIP structure you can find here . More information about Maven archetypes is available here: Maven Archetype","title":"How to create a SIP Adapter using SIP Archetype"},{"location":"changelog/","text":"Changelog \u00b6 All notable changes to this project will be documented in this file. [Unreleased] \u00b6 For unreleased changelogs look into the changelogs directory 2.0.2 - 2022-03-25 \u00b6 \ud83d\udc1e Bugfixes \u00b6 Updated test case for health check on suspended route. #92 by LetoBukarica Resolve context path conflicts in testkit #98 by Nemikor Changed GitHub Actions to ignore missing docs-snapshot folder #99 by LetoBukarica camel.servlet.mapping.context-path configured on core level #95 by vladiIkor Remove maven-enforcer-plugin.version duplicate from framework pom properties #90 by vladiIkor \ud83d\udcd4 Documentation \u00b6 Test Kit documentation added to GitHub pages #86 by vladiIkor Added documentation guide about unit testing with sipmc. #87 by nikolag-ikor Removing dynamic proxy from documentation as it is part of internal architecture, and still not intended for public usage #85 by vladiIkor Tracing documentation updated #88 by dzuci 2.0.0 - 2022-03-14 \u00b6 \ud83d\ude80 Major Changes \u00b6 Java version updated from 8 to 11. Camel version updated from 3.8.0 to 3.14.0. Spring Boot version updated from 2.3.9.RELEASE to 2.6.1. Camel's configuration properties were changed. Full list can be found in official documentation . When upgrading a SIP Adapter with framework version 1.0.0 the following must be changed as it had a default value inside SIP Archetype from camel.component.servlet.mapping.context-path to camel.servlet.mapping.context-path . #55 by nikolag-ikor \u2b50 Features \u00b6 Implementation for actuator info endpoint to expose the basic adapter data and markdown files #51 by nikolag-ikor Added changelog.md and adapter-description.md #41 by Dzuci Implementation of packaging markdown files in jar file. #57 by nikolag-ikor Add application.yaml with spring profile to test resources in archetype #84 by Nemikor SIP Test Kit module is added supporting rest-rest adapter testing #73 by vladiIkor Adding SIP Security to Integration starter and its configuration template to the SIP Archetype application.yaml #70 by nikolag-ikor Refactoring of core proxy unit tests. #67 by nikolag-ikor Added trace-type configuration parameter to handle tracing options #56 by Nemikor Adding sip.security.ssl.enabled switch with false default value #60 by vladiIkor Changing http response status to 200 by default if adapter health results with DOWN #80 by vladiIkor Removed health calculation from actuator health endpoint. Calculation of endpoints health is moved to health check scheduler instead. #37 by nikolag-ikor Added archetype parameter which provides a choice for optional including/excluding of Lombok dependency. #17 by nikolag-ikor Added default mock function (NOOP) to outgoing processors #58 by LetoBukarica Added ProcessorProxy as parameter in ProxyExtension methods #64 by Nemikor Refactored actuator unit tests #36 by Nemikor Refactored security unit tests #43 by Nemikor Refactored sipmc unit tests #42 by Nemikor Refactored trace unit tests #35 by Nemikor Refactored translate unit tests #38 by Nemikor Refactored util unit tests #39 by Nemikor Removed sip.security.authentication.enabled flag, now only authentication provider list is necessary. #30 by Nemikor Implementation for enhanced user experience while creating proxy mocks. #66 by nikolag-ikor Added descriptions for operations and parameters in custom actuator endpoints #32 by Nemikor Updated swagger documentation, added descriptions for possible operations on routes. #3 by Nemikor Updated Apache Camel version to 3.13.0 #24 by Nemikor \ud83d\udc1e Bugfixes \u00b6 Changing access level of AdapterRouteDetails class to public #59 by vladiIkor GroupId is added to archetype generated application/pom.xml #79 by vladiIkor Adding sip.security.ssl.server.client-auth config key to sip-security #19 by vladiIkor Excluding Spring security auto-config classes to prevent default authentication #20 by vladiIkor Enabled adapter-routes to be present in actuator endpoint by default #25 by Nemikor Enabled SpringBoot AutoConfiguration for the Core package #62 by MartinBuchheimIkor Fixed unit tests that fails while running 'mvn install' #44 by Nemicore Adding relative path of adapter's parent in root pom #75 by vladiIkor Updated HealthCheckEnabledCondition to match when HealthEndpoint is enabled #54 by Nemikor Decorating Camel's RouteController in order to add missing logs when route is started and resumed. #71 by vladiIkor Refactored scheduler to be active if property is set to true and HealthEndpoint is enabled #45 by Nemicore Enabled SIP SecurityConfig always - removed the @ConditionalOnSIPSecurityAuthenticationEnabled #65 by LetoBukarica /actuator/health IllegalArgumentException fix when route is suspended #83 by LetoBukarica maven-enforcer-plugin configuration updated according to java version update #82 by vladiIkor \ud83d\udcd4 Documentation \u00b6 Added docs-snapshot directory for documenting unreleased features #52 by Nemikor Added mvn command for creating an archetype on Windows machines #23 by dzuci Add documentation for enabling /actuator/tracing endpoint. #63 by nikolag-ikor Removed adapter-name from endpoint naming convention #33 by Nemikor Fixed missing bad html escaping within main readme file. #22 by nikolag-ikor Removed archetype duplicates in installation.md #40 by dzuci 1.0.0 - 2021-11-18 \u00b6 \ud83d\ude80 Major Changes \u00b6 This is the initial version of the SIP framework. For more information on how to use it and details about features, please refer to the README and to our documentation on https://ikor-gmbh.github.io/sip-framework/. #15 by dannikore","title":"Changelog"},{"location":"changelog/#changelog","text":"All notable changes to this project will be documented in this file.","title":"Changelog"},{"location":"changelog/#unreleased","text":"For unreleased changelogs look into the changelogs directory","title":"[Unreleased]"},{"location":"changelog/#202-2022-03-25","text":"","title":"2.0.2 - 2022-03-25"},{"location":"changelog/#bugfixes","text":"Updated test case for health check on suspended route. #92 by LetoBukarica Resolve context path conflicts in testkit #98 by Nemikor Changed GitHub Actions to ignore missing docs-snapshot folder #99 by LetoBukarica camel.servlet.mapping.context-path configured on core level #95 by vladiIkor Remove maven-enforcer-plugin.version duplicate from framework pom properties #90 by vladiIkor","title":"\ud83d\udc1e Bugfixes"},{"location":"changelog/#documentation","text":"Test Kit documentation added to GitHub pages #86 by vladiIkor Added documentation guide about unit testing with sipmc. #87 by nikolag-ikor Removing dynamic proxy from documentation as it is part of internal architecture, and still not intended for public usage #85 by vladiIkor Tracing documentation updated #88 by dzuci","title":"\ud83d\udcd4 Documentation"},{"location":"changelog/#200-2022-03-14","text":"","title":"2.0.0 - 2022-03-14"},{"location":"changelog/#major-changes","text":"Java version updated from 8 to 11. Camel version updated from 3.8.0 to 3.14.0. Spring Boot version updated from 2.3.9.RELEASE to 2.6.1. Camel's configuration properties were changed. Full list can be found in official documentation . When upgrading a SIP Adapter with framework version 1.0.0 the following must be changed as it had a default value inside SIP Archetype from camel.component.servlet.mapping.context-path to camel.servlet.mapping.context-path . #55 by nikolag-ikor","title":"\ud83d\ude80 Major Changes"},{"location":"changelog/#features","text":"Implementation for actuator info endpoint to expose the basic adapter data and markdown files #51 by nikolag-ikor Added changelog.md and adapter-description.md #41 by Dzuci Implementation of packaging markdown files in jar file. #57 by nikolag-ikor Add application.yaml with spring profile to test resources in archetype #84 by Nemikor SIP Test Kit module is added supporting rest-rest adapter testing #73 by vladiIkor Adding SIP Security to Integration starter and its configuration template to the SIP Archetype application.yaml #70 by nikolag-ikor Refactoring of core proxy unit tests. #67 by nikolag-ikor Added trace-type configuration parameter to handle tracing options #56 by Nemikor Adding sip.security.ssl.enabled switch with false default value #60 by vladiIkor Changing http response status to 200 by default if adapter health results with DOWN #80 by vladiIkor Removed health calculation from actuator health endpoint. Calculation of endpoints health is moved to health check scheduler instead. #37 by nikolag-ikor Added archetype parameter which provides a choice for optional including/excluding of Lombok dependency. #17 by nikolag-ikor Added default mock function (NOOP) to outgoing processors #58 by LetoBukarica Added ProcessorProxy as parameter in ProxyExtension methods #64 by Nemikor Refactored actuator unit tests #36 by Nemikor Refactored security unit tests #43 by Nemikor Refactored sipmc unit tests #42 by Nemikor Refactored trace unit tests #35 by Nemikor Refactored translate unit tests #38 by Nemikor Refactored util unit tests #39 by Nemikor Removed sip.security.authentication.enabled flag, now only authentication provider list is necessary. #30 by Nemikor Implementation for enhanced user experience while creating proxy mocks. #66 by nikolag-ikor Added descriptions for operations and parameters in custom actuator endpoints #32 by Nemikor Updated swagger documentation, added descriptions for possible operations on routes. #3 by Nemikor Updated Apache Camel version to 3.13.0 #24 by Nemikor","title":"\u2b50 Features"},{"location":"changelog/#bugfixes_1","text":"Changing access level of AdapterRouteDetails class to public #59 by vladiIkor GroupId is added to archetype generated application/pom.xml #79 by vladiIkor Adding sip.security.ssl.server.client-auth config key to sip-security #19 by vladiIkor Excluding Spring security auto-config classes to prevent default authentication #20 by vladiIkor Enabled adapter-routes to be present in actuator endpoint by default #25 by Nemikor Enabled SpringBoot AutoConfiguration for the Core package #62 by MartinBuchheimIkor Fixed unit tests that fails while running 'mvn install' #44 by Nemicore Adding relative path of adapter's parent in root pom #75 by vladiIkor Updated HealthCheckEnabledCondition to match when HealthEndpoint is enabled #54 by Nemikor Decorating Camel's RouteController in order to add missing logs when route is started and resumed. #71 by vladiIkor Refactored scheduler to be active if property is set to true and HealthEndpoint is enabled #45 by Nemicore Enabled SIP SecurityConfig always - removed the @ConditionalOnSIPSecurityAuthenticationEnabled #65 by LetoBukarica /actuator/health IllegalArgumentException fix when route is suspended #83 by LetoBukarica maven-enforcer-plugin configuration updated according to java version update #82 by vladiIkor","title":"\ud83d\udc1e Bugfixes"},{"location":"changelog/#documentation_1","text":"Added docs-snapshot directory for documenting unreleased features #52 by Nemikor Added mvn command for creating an archetype on Windows machines #23 by dzuci Add documentation for enabling /actuator/tracing endpoint. #63 by nikolag-ikor Removed adapter-name from endpoint naming convention #33 by Nemikor Fixed missing bad html escaping within main readme file. #22 by nikolag-ikor Removed archetype duplicates in installation.md #40 by dzuci","title":"\ud83d\udcd4 Documentation"},{"location":"changelog/#100-2021-11-18","text":"","title":"1.0.0 - 2021-11-18"},{"location":"changelog/#major-changes_1","text":"This is the initial version of the SIP framework. For more information on how to use it and details about features, please refer to the README and to our documentation on https://ikor-gmbh.github.io/sip-framework/. #15 by dannikore","title":"\ud83d\ude80 Major Changes"},{"location":"core/","text":"IKOR SIP Framework Core \u00b6 IKOR SIP Framework Core Description Usage Features Actuator health check and metrics Working with routes in runtime Logging Translation Changing log level programmatically Exchange tracing OpenAPI Descriptor SIP Details in actuator info endpoint Description \u00b6 Core project for base SIP functionalities Usage \u00b6 To enable SIP Core features use @SIPIntegrationAdapter to annotate the Spring Boot entry class. Features \u00b6 Actuator health check and metrics \u00b6 SIP Core provides out-of-the-box health checks for HTTP(S), JMS and FTP, SFTP and FTPS endpoints. The health check functions will be executed periodically on a set interval and will only be available if actuator's HealthEndpoint is enabled. Actuator can be accessed from {base_url}/actuator To enable/disable health calculation or set its execution interval the following configuration properties are available: sip: core: metrics: external-endpoint-health-check: enabled: true scheduler: fixed-delay: 900000 To customize health checks, or introduce health checks for other kinds of components, it is as simple as implementing the EndpointHealthConfigurer interface @Configuration public class EndpointMonitoringConfiguration { @Bean EndpointHealthConfigurer defaultHttpConfigurer() { return registry -> registry.register(\"http*://**\", HttpHealthIndicators::urlHealthIndicator); } @Bean EndpointHealthConfigurer ftpConfigurer() { return registry -> registry.register(\"*ftp*://**\", FtpHealthIndicators::noopHealthIndicator); } @Bean EndpointHealthConfigurer httpConfigurerById() { return registry -> registry.registerById(\"processor_id\", HttpHealthIndicators::urlHealthIndicator); } } There are a few possible ways to register health check indicators and they will be used in the following priority: by using the id of processor, it will be registered as the exact endpoint URI by using the exact endpoint URI as pattern by using wildcards (*) in pattern, priority is based on how close they match the URI default one for generic components If the same endpoint is used in more than one route, meaning multiple processors with different ids have the same endpoint uri, it is not possible to register 2 different health check functions (check important note below). Only one function per endpoint is possible. Important : If same uri pattern is specified more than one time by any of these methods, DuplicateUriPatternError will be thrown and application will not be able to start. Warning: Only one health indicator may exist for an exact endpoint URI. It is worth noting that the HTTP(S) Health Check lists all existing HTTP(S) endpoints by default, but sets the status to UNKNOWN. The reason for this is that for detected HTTP(S) endpoints a GET request is executed which may cause an unintended change of state of the system to be invoked. Thus this behavior does not occur, health checks should be added explicitly. To add an explicit Health Check for a URL it can be done in the following way. @Bean EndpointHealthConfigurer enableHttpHealthCheckForIKOR() { return registry -> registry.register(\"https://www.ikor.de\", HttpHealthIndicators::urlHealthIndicator); } In case the URL https://www.ikor.de/kontakt.html is requested by the adapter, then on the one hand the explicit URL could be passed as a parameter to register() or wildcards could be used to add a Health Check for this URL and at the same time also matches https://www.ikor.de/karriere.html. The passed argument to register() would look like this https://www.ikor.de/** . However, HTTP(S) Health Checks can only be added for URLs that have also been detected in the adapter. In order to find out what URLs have been discovered one could inspect the result of {base_url}/actuator/health . How to configure endpoint health checks: To inspect the health of Camel endpoints in an integration adapter, one needs to: Make sure that this project uses sip-integration-starter maven dependency. Instead of using @SpringBootApplication, use Java annotation @SIPIntegrationAdapter to annotate the Spring Boot entry class. Configure the application actuator's Health endpoint to display details of health, as shown below. All prerequisites from above are met if you create an integration adapter using SIP archetype. Spring Boot Actuator: #configuring health endpoint management: endpoint: health: show-details: always #or when_authorized if security is in place Health Status Gauge The calculated health status is also available as a gauge inside /actuator/metrics . If all endpoints are healthy it returns 0, otherwise 1. By default, it is named sip.core.metrics.health , but can be changed via configuration. sip: core: metrics: gauge: \"sip.core.metrics.health\" Working with routes in runtime \u00b6 All routes with basic info can be listed by using the following URI: GET /actuator/adapter-routes Getting only routes with sip middle component consumer: GET /actuator/adapter-routes/sipmc More detailed info view for only one exact route can be seen by providing route id into following URI: GET /actuator/adapter-routes/{routeId} The following operations (case sensitive) can be executed per route, for all route or on sipmc: start stop suspend resume reset To execute an operation on all routes, use following URIs: POST /actuator/adapter-routes/{operation} There is a possibility to execute a route lifecycle operation on an exact route, by providing route id and operation. This can be achieved by using following URI: POST /actuator/adapter-routes/{routeId}/{operation} Executing desired operation on the routes without providing route id is possible on sip middle component. By specifying operation on the following URI, operation will be executed for all routes which has sip middle component as a consumer: POST /actuator/adapter-routes/sipmc/{operation} Warning: When using suspend or stop operation on route that has middle component as a consumer, default value (30 seconds) timeout will be used. Keep in mind that if route is not started for next 30 seconds after sending data to middle component, data could be lost. Logging Translation \u00b6 Adds possibility to translate log messages By default, translation service is not activated, thus in order to use it a logback.xml file should be provided in resources. In this file we can specify that the adapter uses a custom logging encoder, which provides translations. <appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\"> <!-- encoders are by default assigned the type ch.qos.logback.classic.encoder.PatternLayoutEncoder --> <encoder class=\"de.ikor.sip.foundation.core.translate.logging.SIPPatternLayoutEncoder\"> <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36}: %msg%n</pattern> </encoder> </appender> Files for defining translation values, should be created inside translate directory as a bundle of .property files, under a common name, which should be extended by a suffix in following format _{language}. Each file consists of keys, shared in the bundle, followed by its value as a phrase in the language used. Warning: Be mindful of how MessageFormat handles String. Some characters, like apostrophe ('), are used as special characters and need to be escaped as shown in the example below. More details can be found here: MessageFormat amessagekey = A message value amessagekey.welcome_{} = Hello {0} amessagekey.missingbean = Bean {0} doesn''t exist The keys are automatically recognized and should be used in logs. log.info(\"amessagekey\"); log.info(\"amessagekey.welcome_{}\", \"A user\"); It can also be automatically used by Camel's log processor. In this case message key MUST be separated from parameters by blank space: .log(\"amessagekey\"); .log(\"amessagekey.welcome_{} ${header.userName}\"); Enabling, disabling and other settings can be done in the configuration. sip: core: translation: fileLocations: classpath:translations/translated-messages, classpath:translations/messages default-encoding: \"UTF-8\" fallback-to-system-locale: false use-code-as-default-message: true lang: en Changing log level programmatically \u00b6 Actuator enables us to dynamically change log levels of all loggers during runtime. This can be accomplished by using the following POST request: http://localhost:8080/actuator/loggers/{logger-name} Header: Content-Type: application/json Body: { \"configuredLevel\": \"TRACE\" } Log levels can be independently changed and will be individually set per logger or on root. We can also use logback.xml auto scan to update log levels. Here we need to enable auto scan and set the interval on which it occurs in logback.xml configuration, and then we can open logback.xml in target directory* and edit the log levels on loggers defined there. <configuration scan=\"true\" scanPeriod=\"30 seconds\"/> This works for all loggers except the ones on Camel routes. Exchange tracing \u00b6 SIP Core offers usage of Camel's built-in Tracer for tracing and logging information about all processor an exchange when through and TraceHistory service which stores all data logged by it. Configuration of the Tracer is enabled by adapting ExchangeFormatter. Tracing functionality is set to false by default. In order to enable it, the following configuration should be added to the application.yml: sip: core: tracing: enabled: true trace-type: LOG | MEMORY | \"*\" | LOG,MEMORY Additionally, trace-type must be defined. Three types of tracing can be used: LOG - trace messages will be shown in logs MEMORY - trace messages will be stored in trace history and can be seen on the \"actuator/tracing\"* \"*\" | LOG,MEMORY - Both values are valid to be used. In case a user set both types, then the tracing will be available as LOG and as MEMORY type at the same time. Note: In order to access trace records trough web API the \"actuator/tracing\" must be exposed: management: endpoints: web: exposure: include: {...},tracing When adding tracing endpoint, please configure the entire list of endpoints which you want to be exposed including the default ones. Configuring the ExchangeFormatter can be achieved in two ways: through configuration file sip: core: tracing: enabled: true exchange-formatter: multiline: true showHeaders: true showExchangeId: true showProperties: true maxChars: 100 ``` - by using the following POST request /actuator/tracing/format/{exchangeFormatterParameterName} ``` The body of the request should include the value we want for the given parameter. In this case, we can change only one parameter per request. TraceHistory is enabled with previous configuration. Exchanges will contain the \"tracingId\" header, which has the original Exchange's id as value. To see them in TraceHistory messages just set the \"showHeaders\" and \"showExchangeId\" parameters in ExchangeFormatter to true. A \"tracingId' header will appear and will be linked to the original Exchange's id. Expanding the traffic trace limit: Introduced the SipLimitedLinkedList in order to limit the number of logged events in memory. Default limit is 100 events, but it could be changed by following configuration: sip: core: tracing: enabled: true limit: 120 #100 by default OpenAPI Descriptor \u00b6 Framework provides an Open API description of all custom or Spring provided endpoints within your adapter. Endpoints are created as extension of Spring's actuator. By using a sip-archetype code generator, you receive an adapter with a default setup for OpenAPI. For working with Swagger OpenAPI, check their official documentation . Adding Custom Swagger Docs: SIP Framework provides a Swagger documentation for the actuator endpoints out of the box. In case a custom Swagger documentation is needed it could be added by including the Swagger Apache Camel component. This component is only supporting the REST DSL component. For controller classes annotated with @RestController an entry is added to the default swagger docs. This might not be the expected behavior for which reason the REST DSL component is recommended. The custom Swagger documentation could easily be added by defining it in the restConfiguration as seen in the following listing. restConfiguration() .contextPath(\"/adapter\") .apiContextPath(\"/api-docs\") .apiContextRouteId(\"api-docs\"); If the application has a route based on the REST DSL a Swagger documentation is generated automatically. rest(\"/api/v1\") .tag(\"Data Controller\").description(\"REST service for creating new objects\") .consumes(MediaType.APPLICATION_JSON_VALUE).produces(MediaType.APPLICATION_JSON_VALUE) .post(\"/data\") .type(DataRequest.class) .description(\"Create a new object\") .outType(DataResponse.class) .to(\"direct:handleRequest\"); This will create a new Swagger documentation for the REST service. For further informations see the Apache Camel documentation of the Swagger and REST DSL component. In case the custom Swagger documentation should be displayed by default in the Swagger UI you can configure it accordingly in the application.yaml file. springdoc: show-actuator: true api-docs: path: /api-docs #default swagger docs swagger-ui: url: /adapter/api-docs #custom swagger docs set as default path: /swagger-ui.html Based on this configuration the custom Swagger documentation is accessible by /adapter/api-docs . SIP Details in actuator info endpoint \u00b6 Under actuator endpoint /actuator/info there is basic information about the adapter ( adapter-name , adapter-version , sip-framework-version ). Additionally, there is also a list of all markdown files located in the adapter root directory, with their names and content exposed. By default, a mandatory build-info maven plugin is located in the pom.xml of adapter's application module, which provides all basic information for this feature. We highly recommend using this plugin in your adapter! Warning about potential issue during development: There is one unpredictable problem with this feature that could happen only in your local environment and it depends on IDE used for development. It is happening only after initial adapter generation and build/rebuild process is executed after mvn clean install command. Keep in mind that even if build and rebuild processes are not executed explicitly, simple running of the adapter could execute them in the background, depending on IDE used. Build/rebuild processes are deleting some generated sources. In our case build-info.properties which is used for fetching adapter basic information is deleted. The problem itself could be resolved by doing build/rebuild explicitly before mvn clean install . Or for example in IntelliJ IDE by updating the specific settings: Uncheck \"Clear Output Directory On Rebuild\" field which can be found under File -> Settings -> Build, Execution, Deployment -> Compiler. Keep in mind that this setup has to be done with every new adapter created or new IntelliJ repository used. Check the image and additional warning message by IntelliJ: \"WARNING! If option 'Clear output directory on rebuild' is enabled, the entire contents of directories where generated sources are stored WILL BE CLEARED on rebuild.\"","title":"Core"},{"location":"core/#ikor-sip-framework-core","text":"IKOR SIP Framework Core Description Usage Features Actuator health check and metrics Working with routes in runtime Logging Translation Changing log level programmatically Exchange tracing OpenAPI Descriptor SIP Details in actuator info endpoint","title":"IKOR SIP Framework Core"},{"location":"core/#description","text":"Core project for base SIP functionalities","title":"Description"},{"location":"core/#usage","text":"To enable SIP Core features use @SIPIntegrationAdapter to annotate the Spring Boot entry class.","title":"Usage"},{"location":"core/#features","text":"","title":"Features"},{"location":"core/#actuator-health-check-and-metrics","text":"SIP Core provides out-of-the-box health checks for HTTP(S), JMS and FTP, SFTP and FTPS endpoints. The health check functions will be executed periodically on a set interval and will only be available if actuator's HealthEndpoint is enabled. Actuator can be accessed from {base_url}/actuator To enable/disable health calculation or set its execution interval the following configuration properties are available: sip: core: metrics: external-endpoint-health-check: enabled: true scheduler: fixed-delay: 900000 To customize health checks, or introduce health checks for other kinds of components, it is as simple as implementing the EndpointHealthConfigurer interface @Configuration public class EndpointMonitoringConfiguration { @Bean EndpointHealthConfigurer defaultHttpConfigurer() { return registry -> registry.register(\"http*://**\", HttpHealthIndicators::urlHealthIndicator); } @Bean EndpointHealthConfigurer ftpConfigurer() { return registry -> registry.register(\"*ftp*://**\", FtpHealthIndicators::noopHealthIndicator); } @Bean EndpointHealthConfigurer httpConfigurerById() { return registry -> registry.registerById(\"processor_id\", HttpHealthIndicators::urlHealthIndicator); } } There are a few possible ways to register health check indicators and they will be used in the following priority: by using the id of processor, it will be registered as the exact endpoint URI by using the exact endpoint URI as pattern by using wildcards (*) in pattern, priority is based on how close they match the URI default one for generic components If the same endpoint is used in more than one route, meaning multiple processors with different ids have the same endpoint uri, it is not possible to register 2 different health check functions (check important note below). Only one function per endpoint is possible. Important : If same uri pattern is specified more than one time by any of these methods, DuplicateUriPatternError will be thrown and application will not be able to start. Warning: Only one health indicator may exist for an exact endpoint URI. It is worth noting that the HTTP(S) Health Check lists all existing HTTP(S) endpoints by default, but sets the status to UNKNOWN. The reason for this is that for detected HTTP(S) endpoints a GET request is executed which may cause an unintended change of state of the system to be invoked. Thus this behavior does not occur, health checks should be added explicitly. To add an explicit Health Check for a URL it can be done in the following way. @Bean EndpointHealthConfigurer enableHttpHealthCheckForIKOR() { return registry -> registry.register(\"https://www.ikor.de\", HttpHealthIndicators::urlHealthIndicator); } In case the URL https://www.ikor.de/kontakt.html is requested by the adapter, then on the one hand the explicit URL could be passed as a parameter to register() or wildcards could be used to add a Health Check for this URL and at the same time also matches https://www.ikor.de/karriere.html. The passed argument to register() would look like this https://www.ikor.de/** . However, HTTP(S) Health Checks can only be added for URLs that have also been detected in the adapter. In order to find out what URLs have been discovered one could inspect the result of {base_url}/actuator/health . How to configure endpoint health checks: To inspect the health of Camel endpoints in an integration adapter, one needs to: Make sure that this project uses sip-integration-starter maven dependency. Instead of using @SpringBootApplication, use Java annotation @SIPIntegrationAdapter to annotate the Spring Boot entry class. Configure the application actuator's Health endpoint to display details of health, as shown below. All prerequisites from above are met if you create an integration adapter using SIP archetype. Spring Boot Actuator: #configuring health endpoint management: endpoint: health: show-details: always #or when_authorized if security is in place Health Status Gauge The calculated health status is also available as a gauge inside /actuator/metrics . If all endpoints are healthy it returns 0, otherwise 1. By default, it is named sip.core.metrics.health , but can be changed via configuration. sip: core: metrics: gauge: \"sip.core.metrics.health\"","title":"Actuator health check and metrics"},{"location":"core/#working-with-routes-in-runtime","text":"All routes with basic info can be listed by using the following URI: GET /actuator/adapter-routes Getting only routes with sip middle component consumer: GET /actuator/adapter-routes/sipmc More detailed info view for only one exact route can be seen by providing route id into following URI: GET /actuator/adapter-routes/{routeId} The following operations (case sensitive) can be executed per route, for all route or on sipmc: start stop suspend resume reset To execute an operation on all routes, use following URIs: POST /actuator/adapter-routes/{operation} There is a possibility to execute a route lifecycle operation on an exact route, by providing route id and operation. This can be achieved by using following URI: POST /actuator/adapter-routes/{routeId}/{operation} Executing desired operation on the routes without providing route id is possible on sip middle component. By specifying operation on the following URI, operation will be executed for all routes which has sip middle component as a consumer: POST /actuator/adapter-routes/sipmc/{operation} Warning: When using suspend or stop operation on route that has middle component as a consumer, default value (30 seconds) timeout will be used. Keep in mind that if route is not started for next 30 seconds after sending data to middle component, data could be lost.","title":"Working with routes in runtime"},{"location":"core/#logging-translation","text":"Adds possibility to translate log messages By default, translation service is not activated, thus in order to use it a logback.xml file should be provided in resources. In this file we can specify that the adapter uses a custom logging encoder, which provides translations. <appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\"> <!-- encoders are by default assigned the type ch.qos.logback.classic.encoder.PatternLayoutEncoder --> <encoder class=\"de.ikor.sip.foundation.core.translate.logging.SIPPatternLayoutEncoder\"> <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36}: %msg%n</pattern> </encoder> </appender> Files for defining translation values, should be created inside translate directory as a bundle of .property files, under a common name, which should be extended by a suffix in following format _{language}. Each file consists of keys, shared in the bundle, followed by its value as a phrase in the language used. Warning: Be mindful of how MessageFormat handles String. Some characters, like apostrophe ('), are used as special characters and need to be escaped as shown in the example below. More details can be found here: MessageFormat amessagekey = A message value amessagekey.welcome_{} = Hello {0} amessagekey.missingbean = Bean {0} doesn''t exist The keys are automatically recognized and should be used in logs. log.info(\"amessagekey\"); log.info(\"amessagekey.welcome_{}\", \"A user\"); It can also be automatically used by Camel's log processor. In this case message key MUST be separated from parameters by blank space: .log(\"amessagekey\"); .log(\"amessagekey.welcome_{} ${header.userName}\"); Enabling, disabling and other settings can be done in the configuration. sip: core: translation: fileLocations: classpath:translations/translated-messages, classpath:translations/messages default-encoding: \"UTF-8\" fallback-to-system-locale: false use-code-as-default-message: true lang: en","title":"Logging Translation"},{"location":"core/#changing-log-level-programmatically","text":"Actuator enables us to dynamically change log levels of all loggers during runtime. This can be accomplished by using the following POST request: http://localhost:8080/actuator/loggers/{logger-name} Header: Content-Type: application/json Body: { \"configuredLevel\": \"TRACE\" } Log levels can be independently changed and will be individually set per logger or on root. We can also use logback.xml auto scan to update log levels. Here we need to enable auto scan and set the interval on which it occurs in logback.xml configuration, and then we can open logback.xml in target directory* and edit the log levels on loggers defined there. <configuration scan=\"true\" scanPeriod=\"30 seconds\"/> This works for all loggers except the ones on Camel routes.","title":"Changing log level programmatically"},{"location":"core/#exchange-tracing","text":"SIP Core offers usage of Camel's built-in Tracer for tracing and logging information about all processor an exchange when through and TraceHistory service which stores all data logged by it. Configuration of the Tracer is enabled by adapting ExchangeFormatter. Tracing functionality is set to false by default. In order to enable it, the following configuration should be added to the application.yml: sip: core: tracing: enabled: true trace-type: LOG | MEMORY | \"*\" | LOG,MEMORY Additionally, trace-type must be defined. Three types of tracing can be used: LOG - trace messages will be shown in logs MEMORY - trace messages will be stored in trace history and can be seen on the \"actuator/tracing\"* \"*\" | LOG,MEMORY - Both values are valid to be used. In case a user set both types, then the tracing will be available as LOG and as MEMORY type at the same time. Note: In order to access trace records trough web API the \"actuator/tracing\" must be exposed: management: endpoints: web: exposure: include: {...},tracing When adding tracing endpoint, please configure the entire list of endpoints which you want to be exposed including the default ones. Configuring the ExchangeFormatter can be achieved in two ways: through configuration file sip: core: tracing: enabled: true exchange-formatter: multiline: true showHeaders: true showExchangeId: true showProperties: true maxChars: 100 ``` - by using the following POST request /actuator/tracing/format/{exchangeFormatterParameterName} ``` The body of the request should include the value we want for the given parameter. In this case, we can change only one parameter per request. TraceHistory is enabled with previous configuration. Exchanges will contain the \"tracingId\" header, which has the original Exchange's id as value. To see them in TraceHistory messages just set the \"showHeaders\" and \"showExchangeId\" parameters in ExchangeFormatter to true. A \"tracingId' header will appear and will be linked to the original Exchange's id. Expanding the traffic trace limit: Introduced the SipLimitedLinkedList in order to limit the number of logged events in memory. Default limit is 100 events, but it could be changed by following configuration: sip: core: tracing: enabled: true limit: 120 #100 by default","title":"Exchange tracing"},{"location":"core/#openapi-descriptor","text":"Framework provides an Open API description of all custom or Spring provided endpoints within your adapter. Endpoints are created as extension of Spring's actuator. By using a sip-archetype code generator, you receive an adapter with a default setup for OpenAPI. For working with Swagger OpenAPI, check their official documentation . Adding Custom Swagger Docs: SIP Framework provides a Swagger documentation for the actuator endpoints out of the box. In case a custom Swagger documentation is needed it could be added by including the Swagger Apache Camel component. This component is only supporting the REST DSL component. For controller classes annotated with @RestController an entry is added to the default swagger docs. This might not be the expected behavior for which reason the REST DSL component is recommended. The custom Swagger documentation could easily be added by defining it in the restConfiguration as seen in the following listing. restConfiguration() .contextPath(\"/adapter\") .apiContextPath(\"/api-docs\") .apiContextRouteId(\"api-docs\"); If the application has a route based on the REST DSL a Swagger documentation is generated automatically. rest(\"/api/v1\") .tag(\"Data Controller\").description(\"REST service for creating new objects\") .consumes(MediaType.APPLICATION_JSON_VALUE).produces(MediaType.APPLICATION_JSON_VALUE) .post(\"/data\") .type(DataRequest.class) .description(\"Create a new object\") .outType(DataResponse.class) .to(\"direct:handleRequest\"); This will create a new Swagger documentation for the REST service. For further informations see the Apache Camel documentation of the Swagger and REST DSL component. In case the custom Swagger documentation should be displayed by default in the Swagger UI you can configure it accordingly in the application.yaml file. springdoc: show-actuator: true api-docs: path: /api-docs #default swagger docs swagger-ui: url: /adapter/api-docs #custom swagger docs set as default path: /swagger-ui.html Based on this configuration the custom Swagger documentation is accessible by /adapter/api-docs .","title":"OpenAPI Descriptor"},{"location":"core/#sip-details-in-actuator-info-endpoint","text":"Under actuator endpoint /actuator/info there is basic information about the adapter ( adapter-name , adapter-version , sip-framework-version ). Additionally, there is also a list of all markdown files located in the adapter root directory, with their names and content exposed. By default, a mandatory build-info maven plugin is located in the pom.xml of adapter's application module, which provides all basic information for this feature. We highly recommend using this plugin in your adapter! Warning about potential issue during development: There is one unpredictable problem with this feature that could happen only in your local environment and it depends on IDE used for development. It is happening only after initial adapter generation and build/rebuild process is executed after mvn clean install command. Keep in mind that even if build and rebuild processes are not executed explicitly, simple running of the adapter could execute them in the background, depending on IDE used. Build/rebuild processes are deleting some generated sources. In our case build-info.properties which is used for fetching adapter basic information is deleted. The problem itself could be resolved by doing build/rebuild explicitly before mvn clean install . Or for example in IntelliJ IDE by updating the specific settings: Uncheck \"Clear Output Directory On Rebuild\" field which can be found under File -> Settings -> Build, Execution, Deployment -> Compiler. Keep in mind that this setup has to be done with every new adapter created or new IntelliJ repository used. Check the image and additional warning message by IntelliJ: \"WARNING! If option 'Clear output directory on rebuild' is enabled, the entire contents of directories where generated sources are stored WILL BE CLEARED on rebuild.\"","title":"SIP Details in actuator info endpoint"},{"location":"installation/","text":"Installation guide \u00b6 Installation guide Software requirements Java Virtual Machine Maven IDE Plugins Create a SIP Adapter using SIP Archetype Software requirements \u00b6 Before getting started to develop a first adapter with SIP the following requirements should be fulfilled: Java Virtual Machine \u00b6 Recommendation for using Java 11 or higher https://www.oracle.com/java/technologies/javase/jdk11-archive-downloads.html Maven \u00b6 Maven downloaded from https://maven.apache.org/download.cgi For the Maven documentation see https://maven.apache.org/guides/ IDE \u00b6 IntelliJ - Download from https://www.jetbrains.com/idea/download/#section=windows Eclipse - Download from https://www.eclipse.org/downloads/ Plugins \u00b6 Lombok with IntelliJ https://projectlombok.org/setup/intellij Lombok with Eclipse https://projectlombok.org/setup/eclipse Apache Camel with IntelliJ (recommendation) https://plugins.jetbrains.com/plugin/9371-apache-camel Create a SIP Adapter using SIP Archetype \u00b6 Guide for creating a new SIP Adapter from archetype can be found here .","title":"Installation Guide"},{"location":"installation/#installation-guide","text":"Installation guide Software requirements Java Virtual Machine Maven IDE Plugins Create a SIP Adapter using SIP Archetype","title":"Installation guide"},{"location":"installation/#software-requirements","text":"Before getting started to develop a first adapter with SIP the following requirements should be fulfilled:","title":"Software requirements"},{"location":"installation/#java-virtual-machine","text":"Recommendation for using Java 11 or higher https://www.oracle.com/java/technologies/javase/jdk11-archive-downloads.html","title":"Java Virtual Machine"},{"location":"installation/#maven","text":"Maven downloaded from https://maven.apache.org/download.cgi For the Maven documentation see https://maven.apache.org/guides/","title":"Maven"},{"location":"installation/#ide","text":"IntelliJ - Download from https://www.jetbrains.com/idea/download/#section=windows Eclipse - Download from https://www.eclipse.org/downloads/","title":"IDE"},{"location":"installation/#plugins","text":"Lombok with IntelliJ https://projectlombok.org/setup/intellij Lombok with Eclipse https://projectlombok.org/setup/eclipse Apache Camel with IntelliJ (recommendation) https://plugins.jetbrains.com/plugin/9371-apache-camel","title":"Plugins"},{"location":"installation/#create-a-sip-adapter-using-sip-archetype","text":"Guide for creating a new SIP Adapter from archetype can be found here .","title":"Create a SIP Adapter using SIP Archetype"},{"location":"integration-starter/","text":"SIP Integration Starter \u00b6 SIP Integration Starter Description Includes Usage Description \u00b6 Starter project used to add necessary predefined dependencies for development of integration adapters Includes \u00b6 IKOR SIP Components dependencies Camel dependencies Spring dependencies Usage \u00b6 Add sip-integration-starter dependency to project. <dependency> <groupId>de.ikor.sip.foundation</groupId> <artifactId>sip-integration-starter</artifactId> <version>${sip.integration.starter}</version> </dependency>","title":"Integration Starter"},{"location":"integration-starter/#sip-integration-starter","text":"SIP Integration Starter Description Includes Usage","title":"SIP Integration Starter"},{"location":"integration-starter/#description","text":"Starter project used to add necessary predefined dependencies for development of integration adapters","title":"Description"},{"location":"integration-starter/#includes","text":"IKOR SIP Components dependencies Camel dependencies Spring dependencies","title":"Includes"},{"location":"integration-starter/#usage","text":"Add sip-integration-starter dependency to project. <dependency> <groupId>de.ikor.sip.foundation</groupId> <artifactId>sip-integration-starter</artifactId> <version>${sip.integration.starter}</version> </dependency>","title":"Usage"},{"location":"license/","text":"Apache License Version 2.0, January 2004 http://www.apache.org/licenses/ TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION Definitions. \"License\" shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document. \"Licensor\" shall mean the copyright owner or entity authorized by the copyright owner that is granting the License. \"Legal Entity\" shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \"control\" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity. \"You\" (or \"Your\") shall mean an individual or Legal Entity exercising permissions granted by this License. \"Source\" form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files. \"Object\" form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types. \"Work\" shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below). \"Derivative Works\" shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof. \"Contribution\" shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \"submitted\" means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \"Not a Contribution.\" \"Contributor\" shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work. Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form. Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed. Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions: (a) You must give any other recipients of the Work or Derivative Works a copy of this License; and (b) You must cause any modified files to carry prominent notices stating that You changed the files; and (c) You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and (d) If the Work includes a \"NOTICE\" text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License. You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License. Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions. Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file. Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License. Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages. Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability. END OF TERMS AND CONDITIONS APPENDIX: How to apply the Apache License to your work. To apply the Apache License to your work, attach the following boilerplate notice, with the fields enclosed by brackets \"[]\" replaced with your own identifying information. (Don't include the brackets!) The text should be enclosed in the appropriate comment syntax for the file format. We also recommend that a file or class name and description of purpose be included on the same \"printed page\" as the copyright notice for easier identification within third-party archives. Copyright [yyyy] [name of copyright owner] Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"middle-component/","text":"IKOR SIP Middle Component \u00b6 IKOR SIP Middle Component Description How to use Examples Unit testing with sipmc Description \u00b6 SIP middle component relates to the key SIP concept - splitting integration logic into submodules (connectors). Combining connectors into one data flow is quite easy with Camel and can be done in many ways. However, if we do it with one of Camel's existing component, we couldn't be sure if it represents connection between connectors or just some intermediate routing within the single connector. If we (properly) use sipmc component, it provides a clear functional and visual distinction between a connector's ending or beginning. With it, adapter routes become more standardized and manageable. Middle component is also a point of higher control over Apache Camel flow, as it provides a placeholder for future customizations which will make it easier to bridge connectors in different ways, e.g. by using JMS broker implicitly if configured. Middle component hides connecting technology and makes connection of two sub-systems abstract and simple. Current version supports only in-memory connection channel implemented on top of Camel's SEDA component. It provides 1 to 1 and publish-subscribe patterns and can support many channels in single adapter. Middle component can automatically determine the number of consumers for a specific channel and auto-configure itself accordingly, as a 1 to 1 or publish-subscribe connector. How to use \u00b6 Middle component is used like any other Camel component, but has a simple URI pattern: sipmc:channelName The channel name is an arbitrary String value, but it should relate to one integration topic, e.q. partner. Multiple sipmc routes may exist with different channel names. Examples \u00b6 1 to 1: In this scenario response provided by \"mock:output\" should be propagated back to the caller - \"mock:input\" from(\"mock:input\") .to(\"sipmc:foo\"); from(\"sipmc:foo\") .to(\"mock:output\"); Publish subscribe: With publish-subscribe pattern the caller (mock-input) does not know how many consumers are registered. Middle component makes sure the message is delivered to all of them. Notice that the URIs do not differ too much from the ones in previous case. from(\"mock:input\") .to(\"sipmc:foo\"); from(\"sipmc:foo\") .to(\"mock:output1\"); from(\"sipmc:foo\") .to(\"mock:output2\"); Unit testing with sipmc \u00b6 Middle Component, as any custom Camel component, should be mocked within unit tests which test and cover Camel routes. Otherwise, running the test will run the route within Camel context without Middle component and test will fail running. When doing Camel testing, if you use Camel's CamelTestSupport class, Middle component can be mocked by using AdwiceWith inside your test. Following code and methods within Advice can be used for mocking sipmc: @Test void test() throws Exception { // arrange AdviceWith.adviceWith(context.getRouteDefinitions().get(0), context, new AdviceWithRouteBuilder() { @Override public void configure() throws Exception { // replace sipmc consumer with mocking seda replaceFromWith(\"seda:mockConsumer\"); // replace sipmc producer with mocking seda weaveByToUri(\"sipmc:someChannel\").replace().to(\"seda:mockProducer\"); } }); context().start(); }","title":"Middle Component"},{"location":"middle-component/#ikor-sip-middle-component","text":"IKOR SIP Middle Component Description How to use Examples Unit testing with sipmc","title":"IKOR SIP Middle Component"},{"location":"middle-component/#description","text":"SIP middle component relates to the key SIP concept - splitting integration logic into submodules (connectors). Combining connectors into one data flow is quite easy with Camel and can be done in many ways. However, if we do it with one of Camel's existing component, we couldn't be sure if it represents connection between connectors or just some intermediate routing within the single connector. If we (properly) use sipmc component, it provides a clear functional and visual distinction between a connector's ending or beginning. With it, adapter routes become more standardized and manageable. Middle component is also a point of higher control over Apache Camel flow, as it provides a placeholder for future customizations which will make it easier to bridge connectors in different ways, e.g. by using JMS broker implicitly if configured. Middle component hides connecting technology and makes connection of two sub-systems abstract and simple. Current version supports only in-memory connection channel implemented on top of Camel's SEDA component. It provides 1 to 1 and publish-subscribe patterns and can support many channels in single adapter. Middle component can automatically determine the number of consumers for a specific channel and auto-configure itself accordingly, as a 1 to 1 or publish-subscribe connector.","title":"Description"},{"location":"middle-component/#how-to-use","text":"Middle component is used like any other Camel component, but has a simple URI pattern: sipmc:channelName The channel name is an arbitrary String value, but it should relate to one integration topic, e.q. partner. Multiple sipmc routes may exist with different channel names.","title":"How to use"},{"location":"middle-component/#examples","text":"1 to 1: In this scenario response provided by \"mock:output\" should be propagated back to the caller - \"mock:input\" from(\"mock:input\") .to(\"sipmc:foo\"); from(\"sipmc:foo\") .to(\"mock:output\"); Publish subscribe: With publish-subscribe pattern the caller (mock-input) does not know how many consumers are registered. Middle component makes sure the message is delivered to all of them. Notice that the URIs do not differ too much from the ones in previous case. from(\"mock:input\") .to(\"sipmc:foo\"); from(\"sipmc:foo\") .to(\"mock:output1\"); from(\"sipmc:foo\") .to(\"mock:output2\");","title":"Examples"},{"location":"middle-component/#unit-testing-with-sipmc","text":"Middle Component, as any custom Camel component, should be mocked within unit tests which test and cover Camel routes. Otherwise, running the test will run the route within Camel context without Middle component and test will fail running. When doing Camel testing, if you use Camel's CamelTestSupport class, Middle component can be mocked by using AdwiceWith inside your test. Following code and methods within Advice can be used for mocking sipmc: @Test void test() throws Exception { // arrange AdviceWith.adviceWith(context.getRouteDefinitions().get(0), context, new AdviceWithRouteBuilder() { @Override public void configure() throws Exception { // replace sipmc consumer with mocking seda replaceFromWith(\"seda:mockConsumer\"); // replace sipmc producer with mocking seda weaveByToUri(\"sipmc:someChannel\").replace().to(\"seda:mockProducer\"); } }); context().start(); }","title":"Unit testing with sipmc"},{"location":"security/","text":"SIP Security \u00b6 SIP Security Introduction Installation Configuration SSL Authentication Definitions Examples Additional information Introduction \u00b6 What is SIP Security? SIP Security is built on top of Spring Security and is trying to ease and streamline the usage of Security related aspects, but also add some enterprise grade features which are, from our perspective, quite relevant and helpful. Why use it? Nowadays, security is one of the most important topics in every application. Implementing code and configuration on top of Spring Security should help you jump-start your adapter development (along with the archetype), not waste your time, and enable you to focus on your core tasks - resolving integration problems. Installation \u00b6 Adding the Maven dependency for SIP Security should be enough to boostrap it. For proper configuration please refer to the \"Configuration\" chapter. <dependency> <groupId>de.ikor.sip.foundation</groupId> <artifactId>sip-security</artifactId> </dependency> SIP Security dependency is included by default when creating adapter with SIP Archetype. Note: Spring Security dependency will also be added as a transitive one. Configuration \u00b6 Following description shows SIP Security functionalities and configuration. Valid configuration is needed to be able to properly utilize SIP security, no additional coding is required. SSL \u00b6 SSL is by default turned off. It can be activated by turning it on explicitly either on a client or on a sever side. Client SSL is by default using a server certificate. If no server certificate is set a client certificate is mandatory when turning on client SSL. Client (our application is consuming APIs using the provided certificate) sip.security: ssl: client: enabled: true #true / false (default); if enabled but no other configs are made, server keystore is used as client certificate key-store: classpath:keystore.p12 # possible resource strings are classpath:, file:, http:, _none_ key-store-password: password # we recommend to use env_vars or sealed secrets key-store-type: pkcs12 #possible options are pkcs12, jks, jceks key-alias: springboot #the alias of the key to be chosen from the container key-password: password # we recommend to use env_vars or sealed secrets To turn off the usage of client SSL check (default): sip.security: ssl: client: enabled: false The truststore is handled with Java default: set the cacerts in the runtime accordingly (preferable approach) for local development you could add any certificate, IntermediateCA, RootCA or complete certificate chain to the keystore as a trusted certificate (e.g. by importing it with tools like keytool), a possible command could be: keytool -importcert -file certificate.cer -keystore keystore.jks -alias \"Alias\" Server (our application is providing APIs using the provided certificate) sip.security: ssl: server: key-store: classpath:keystore.p12 # possible resource strings are classpath:, file:, http:, _none_ key-store-password: password # we recommend to use env_vars or sealed secrets key-store-type: pkcs12 #possible options are pkcs12, jks, jceks key-alias: springboot #the alias of the key to be chosen from the container key-password: password # we recommend to use env_vars or sealed secrets client-auth: want # Could be: need (client auth is mandatory), want (client auth is is wanted but not # mandatory) and none (default) To turn the usage of the server certificate off: sip.security: ssl: enabled: false Authentication \u00b6 Global authentication configuration: sip.security: authentication: disable-csrf: true ignored-endpoints: #a list of endpoints which are ignored by ALL authenticators based on Spring\u00b4s AntPathMatchers implementation - /actuator - /actuator/** - /favicon.ico Definitions \u00b6 These are the basic building blocks of authentication mechanism: - Extractors -Extract the relevant Token from a HTTP Requests - BasicAuth: Extracts the BasicAuth credentials from the request Header - X509: Extracts the X509 certificate from the request (requires sip.security.ssl.server.client-auth set to need or want - none is by default) - Providers - Triggers a Validator to validate a given authentication request - BasicAuth: Takes the extracted basic auth token and uses the given validator from the configuration to validate the token - X509: Takes the extracted X509 token and uses the given validator from the configuration to validate the token - Validators - Validates a given token against a provided list of valid user credentials which are provided via configuration Examples \u00b6 BasicAuth sip.security: authentication: auth-providers: #authentication functionality is enabled if valid providers are defined - classname: de.ikor.sip.foundation.security.authentication.basic.SIPBasicAuthAuthenticationProvider ignored-endpoints: #a list of endpoints which are ignored by this specific authenticator based on Spring\u00b4s AntPathMatchers implementation - /actuator/health - /actuator/env validation: classname: de.ikor.sip.foundation.security.authentication.basic.SIPBasicAuthFileValidator #FQCN of the validator to be used file-path: classpath:basic-auth-users.json # possible resource strings are classpath:, file:, http:, _none_ Sample file basic-auth-users.json : [ {\"username\": \"user1\", \"password\": \"pw1\"}, {\"username\": \"anotherUser\", \"password\": \"anotherPassword\"} ] X509 Configuration: sip.security: authentication: auth-providers: #authentication functionality is enabled if valid providers are defined - classname: de.ikor.sip.foundation.security.authentication.x509.SIPX509AuthenticationProvider ignored-endpoints: #a list of endpoints which are ignored by this specific authenticator based on Spring\u00b4s AntPathMatchers implementation - /favicon.ico - /actuator/env validation: classname: de.ikor.sip.foundation.security.authentication.x509.SIPX509FileValidator #FQCN of the validator to be used file-path: classpath:client-certs.acl # possible resource strings are classpath:, file:, http:, _none_ Sample file client-certs.acl : CN=Full Name, EMAILADDRESS=name@domain.de, O=[*], C=DE CN=Full Name2, EMAILADDRESS=name2@domain.de, O=[*], C=DE Additional information \u00b6 ACL in the context of SIP Security and X509 is our implementation of an Access Control List . SIPX509FileValidator uses a given .acl file to grant access to respective users. This SIP specific feature is not related to Spring Security\u00b4s ACL implementation. The high-level intention is to limit the access to the provided API. If this feature is used client certificates are needed. To set the password for configuration value sip.security.ssl.server.key-store-password by environment variable you can do the following in your (bash) shell (Spring will automatically find the correct variable and set the value): export SIP_SECURITY_SSL_SERVER_KEY_STORE_PASSWORD=\"password\"","title":"Security"},{"location":"security/#sip-security","text":"SIP Security Introduction Installation Configuration SSL Authentication Definitions Examples Additional information","title":"SIP Security"},{"location":"security/#introduction","text":"What is SIP Security? SIP Security is built on top of Spring Security and is trying to ease and streamline the usage of Security related aspects, but also add some enterprise grade features which are, from our perspective, quite relevant and helpful. Why use it? Nowadays, security is one of the most important topics in every application. Implementing code and configuration on top of Spring Security should help you jump-start your adapter development (along with the archetype), not waste your time, and enable you to focus on your core tasks - resolving integration problems.","title":"Introduction"},{"location":"security/#installation","text":"Adding the Maven dependency for SIP Security should be enough to boostrap it. For proper configuration please refer to the \"Configuration\" chapter. <dependency> <groupId>de.ikor.sip.foundation</groupId> <artifactId>sip-security</artifactId> </dependency> SIP Security dependency is included by default when creating adapter with SIP Archetype. Note: Spring Security dependency will also be added as a transitive one.","title":"Installation"},{"location":"security/#configuration","text":"Following description shows SIP Security functionalities and configuration. Valid configuration is needed to be able to properly utilize SIP security, no additional coding is required.","title":"Configuration"},{"location":"security/#ssl","text":"SSL is by default turned off. It can be activated by turning it on explicitly either on a client or on a sever side. Client SSL is by default using a server certificate. If no server certificate is set a client certificate is mandatory when turning on client SSL. Client (our application is consuming APIs using the provided certificate) sip.security: ssl: client: enabled: true #true / false (default); if enabled but no other configs are made, server keystore is used as client certificate key-store: classpath:keystore.p12 # possible resource strings are classpath:, file:, http:, _none_ key-store-password: password # we recommend to use env_vars or sealed secrets key-store-type: pkcs12 #possible options are pkcs12, jks, jceks key-alias: springboot #the alias of the key to be chosen from the container key-password: password # we recommend to use env_vars or sealed secrets To turn off the usage of client SSL check (default): sip.security: ssl: client: enabled: false The truststore is handled with Java default: set the cacerts in the runtime accordingly (preferable approach) for local development you could add any certificate, IntermediateCA, RootCA or complete certificate chain to the keystore as a trusted certificate (e.g. by importing it with tools like keytool), a possible command could be: keytool -importcert -file certificate.cer -keystore keystore.jks -alias \"Alias\" Server (our application is providing APIs using the provided certificate) sip.security: ssl: server: key-store: classpath:keystore.p12 # possible resource strings are classpath:, file:, http:, _none_ key-store-password: password # we recommend to use env_vars or sealed secrets key-store-type: pkcs12 #possible options are pkcs12, jks, jceks key-alias: springboot #the alias of the key to be chosen from the container key-password: password # we recommend to use env_vars or sealed secrets client-auth: want # Could be: need (client auth is mandatory), want (client auth is is wanted but not # mandatory) and none (default) To turn the usage of the server certificate off: sip.security: ssl: enabled: false","title":"SSL"},{"location":"security/#authentication","text":"Global authentication configuration: sip.security: authentication: disable-csrf: true ignored-endpoints: #a list of endpoints which are ignored by ALL authenticators based on Spring\u00b4s AntPathMatchers implementation - /actuator - /actuator/** - /favicon.ico","title":"Authentication"},{"location":"security/#definitions","text":"These are the basic building blocks of authentication mechanism: - Extractors -Extract the relevant Token from a HTTP Requests - BasicAuth: Extracts the BasicAuth credentials from the request Header - X509: Extracts the X509 certificate from the request (requires sip.security.ssl.server.client-auth set to need or want - none is by default) - Providers - Triggers a Validator to validate a given authentication request - BasicAuth: Takes the extracted basic auth token and uses the given validator from the configuration to validate the token - X509: Takes the extracted X509 token and uses the given validator from the configuration to validate the token - Validators - Validates a given token against a provided list of valid user credentials which are provided via configuration","title":"Definitions"},{"location":"security/#examples","text":"BasicAuth sip.security: authentication: auth-providers: #authentication functionality is enabled if valid providers are defined - classname: de.ikor.sip.foundation.security.authentication.basic.SIPBasicAuthAuthenticationProvider ignored-endpoints: #a list of endpoints which are ignored by this specific authenticator based on Spring\u00b4s AntPathMatchers implementation - /actuator/health - /actuator/env validation: classname: de.ikor.sip.foundation.security.authentication.basic.SIPBasicAuthFileValidator #FQCN of the validator to be used file-path: classpath:basic-auth-users.json # possible resource strings are classpath:, file:, http:, _none_ Sample file basic-auth-users.json : [ {\"username\": \"user1\", \"password\": \"pw1\"}, {\"username\": \"anotherUser\", \"password\": \"anotherPassword\"} ] X509 Configuration: sip.security: authentication: auth-providers: #authentication functionality is enabled if valid providers are defined - classname: de.ikor.sip.foundation.security.authentication.x509.SIPX509AuthenticationProvider ignored-endpoints: #a list of endpoints which are ignored by this specific authenticator based on Spring\u00b4s AntPathMatchers implementation - /favicon.ico - /actuator/env validation: classname: de.ikor.sip.foundation.security.authentication.x509.SIPX509FileValidator #FQCN of the validator to be used file-path: classpath:client-certs.acl # possible resource strings are classpath:, file:, http:, _none_ Sample file client-certs.acl : CN=Full Name, EMAILADDRESS=name@domain.de, O=[*], C=DE CN=Full Name2, EMAILADDRESS=name2@domain.de, O=[*], C=DE","title":"Examples"},{"location":"security/#additional-information","text":"ACL in the context of SIP Security and X509 is our implementation of an Access Control List . SIPX509FileValidator uses a given .acl file to grant access to respective users. This SIP specific feature is not related to Spring Security\u00b4s ACL implementation. The high-level intention is to limit the access to the provided API. If this feature is used client certificates are needed. To set the password for configuration value sip.security.ssl.server.key-store-password by environment variable you can do the following in your (bash) shell (Spring will automatically find the correct variable and set the value): export SIP_SECURITY_SSL_SERVER_KEY_STORE_PASSWORD=\"password\"","title":"Additional information"},{"location":"starter-parent/","text":"SIP Starter Parent \u00b6 SIP Starter Parent Description Usage Description \u00b6 This project takes care of versions (transitive dependencies) for Spring Boot and Camel dependencies. It inherits spring-boot-parent-starter, so that it will, by default, bring everything needed for comfortable development of Spring Boot applications. This includes transitive dependency management of all dependencies used by the Spring Boot starters, but also other dependencies for SIP Adapters, plus additional Maven plugin management and configuration. Usage \u00b6 This project should be used as parent for SIP Adapters. <parent> <groupId>de.ikor.sip.foundation</groupId> <artifactId>sip-starter-parent</artifactId> <version>${sip.starter.parent}</version> </parent>","title":"Starter Parent"},{"location":"starter-parent/#sip-starter-parent","text":"SIP Starter Parent Description Usage","title":"SIP Starter Parent"},{"location":"starter-parent/#description","text":"This project takes care of versions (transitive dependencies) for Spring Boot and Camel dependencies. It inherits spring-boot-parent-starter, so that it will, by default, bring everything needed for comfortable development of Spring Boot applications. This includes transitive dependency management of all dependencies used by the Spring Boot starters, but also other dependencies for SIP Adapters, plus additional Maven plugin management and configuration.","title":"Description"},{"location":"starter-parent/#usage","text":"This project should be used as parent for SIP Adapters. <parent> <groupId>de.ikor.sip.foundation</groupId> <artifactId>sip-starter-parent</artifactId> <version>${sip.starter.parent}</version> </parent>","title":"Usage"},{"location":"test-kit/","text":"IKOR SIP Test Kit \u00b6 IKOR SIP Test Kit Description Features Response validation External endpoint mocking Endpoint reports Endpoint validation Reports How to use Defining a Test Case when-execute with-mocks then-expect Complete example Description \u00b6 SIP Test Kit is a testing system designed to work with SIP integration adapters. It's main purpose is to test how an adapter works internally, by mocking all external communication. It executes a test workflow that is defined in a specific file format, providing a possibility to create tests without code change. This file format is referred to as TestCaseDefinition . The flow itself and thus the TestCaseDefinition file is split into three phases (sections) when-execute - The test is executed by triggering one of adapter's endpoints with-mocks - External calls which are to be replaced with predefined mock behaviour then-expect - The test outcome that should be compared with a predefined expected outcome Features \u00b6 Response validation \u00b6 Major feature of Test Kit is validation of the response from test execution. By adding a validation definition inside the then-expect section and setting that validation for the endpoint we defined in when-execute section, the response of the execution will be validated and a report will be displayed. External endpoint mocking \u00b6 This feature is active whenever a test is executed via test kit. It will provide default behavior (forwarding the request without processing it) and mock all external endpoints. Adding specific behavior for each endpoint can be done in test case definition in 'with-mocks' section. Endpoint reports \u00b6 Test Kit will provide reports for all mocked endpoints, both with default (set by Test Kit) and user defined behavior. For each test report in the 'Endpoints' section there will be an overview of request that each received. Endpoint validation \u00b6 It is possible to also validate body and headers of each mocked endpoint. By defining desired validation inside test case definition file, Test Kit will validate endpoints and display reports for each. Reports \u00b6 As mentioned each test case will be executed as its own unit test, so for each a test report will be generated and printed in console. First part of report is for the response. It will display the validated body and headers, as well as expected ones. The following endpoints part is for mocked endpoint reports, with similar data as in the first part. How to use \u00b6 Test kit is enabled by default when the adapter is generated from archetype. A test class needs to be created inside test package of the adapter, which extends SIPBatchTest. Running this class would execute the test, but also it will be executed during build time. public class TFWTest extends SIPBatchTest { } Also, configuring spring profile is needed. Provide the following configuration property inside your test resources. spring: profiles: active: test The next step is to provide the TestCaseDefinition file in yaml format in the test/resources package (detailed description in next section): test-case-definitions: - title: \"Title of individual test\" when-execute: endpoint: \"id of endpoint under test\" with: body: \"Content that will be send as request body to the adapter endpoint (plain text, JSON String)\" headers: header-key: \"Value of the header\" another-header-key: \"Another value\" with-mocks: - endpoint: \"id of endpoint that should be mocked\" returning: body: \"Response message that real endpoint is expected to return\" then-expect: - endpoint: \"id of endpoint under test\" # matches endpoint under test defined in when phase having: body: \"Regex expression (java) which will be compered to the reponse of the test\" headers: header-key: \"Regex expression (java) which will be compered to the value of this header key\" - endpoint: \"id of endpoint that is mocked\" # matches endpoint with defined or default mocked behavior having: body: \"Regex expression (java) which will be compered to the request which arrived on the endpoint\" headers: header-key: \"Regex expression (java) which will be compered to the header key value from request which arrived on the endpoint\" You also need to provide the location of TestCaseDefinition file to the Test Kit by setting the following property inside adapter configuration: sip.testkit.test-cases-path: myTests.yml The default value is test-case-definition.yml, so you can place your test case description under that file, and skip additional setting. Each test case will execute as a separate unit test with its own report displayed. To disable SIP Test Kit, the following configuration is needed: sip: testkit: enabled: false To be able to fully utilize the Test Kit, all the endpoints used in the test case need to have a defined ID which will be referenced in the endpoint parameter of the test case. Defining a Test Case \u00b6 The TestCaseDefinition file starts with test-case-definitions property, which consists of a list of test cases when-execute \u00b6 In this section a request that should be sent to the adapter is defined. \"endpoint\" refers to ID (routeId in camel routes) of the endpoint to which we wish to send a test request. In \"with\" part we define content of the request we wish to send, meaning body and headers are added here. The body can also be defined as plain text or JSON string, which represents a POJO. when-execute: endpoint: \"rest-endpoint\" with: body: \"body of request\" with-mocks \u00b6 This section contains a list of endpoints for which we wish to have specific mocked behavior. \"endpoint\" is the endpoint ID, (processor ID in camel route) of the mocked endpoint. \"returning\" should have the body, that we expect as the response from real external call. with-mocks: - endpoint: \"external-service\" returning: body: \"response message from service\" then-expect \u00b6 Validation of test response is defined by setting the \"endpoint\" parameter to the ID of endpoint under test and defining the expected body or headers. Also, validation of requests, which mocks received, is defined by setting the \"endpoint\" parameter to the ID of mocked endpoint and defining the expected body or headers. Body and header validation is possible by either defining regex (Java) expression or matching exact String content. then-expect: - endpoint: \"rest-endpoint\" # matches endpoint under test having: body: \"response .* from service\" headers: CamelHttpResponseCode: \"200\" - endpoint: \"external-service\" # matches endpoint with mocked behavior having: body: \"body of request\" headers: test-mode: \"true\" Complete example \u00b6 Sample Route public class SampleRestRoute extends RouteBuilder { public void configure() throws Exception { restConfiguration().component(\"servlet\").port(\"8080\").host(\"localhost\"); // Endpoint under test from(\"rest:POST:/say/hello\").routeId(\"rest-endpoint\").to(\"sipmc:bridge\"); from(\"sipmc:bridge\") .routeId(\"http-route\") // Mocked endpoint .to(\"http:localhost:8081/hello?bridgeEndpoint=true\") .id(\"external-service\"); } } Sample test case definition test-case-definitions: - title: \"Test case 1\" when-execute: endpoint: \"rest-endpoint\" # id of endpoint under test (routeId) with: body: \"body of request\" with-mocks: - endpoint: \"external-service\" # id of endpoint that is mocked (processorId) returning: body: \"response message from service\" then-expect: - endpoint: \"rest-endpoint\" # matches endpoint under test having: body: \"response .* from service\" headers: CamelHttpResponseCode: \"200\" - endpoint: \"external-service\" # matches endpoint with mocked behavior having: body: \"body of request\" headers: test-mode: \"true\" Sample Console Report ----------------------------- | SIP Test Execution Report | ----------------------------- Test \"Test case 1\" executed successfully. Validation details: Body validation successful Header validation successful Actual response: Body: response message from service Validated headers: - CamelHttpResponseCode: 200 Expected response: Body: response .* from service Headers: - CamelHttpResponseCode: 200 Endpoints: Endpoint \"external-service\" was mocked Validation successful Received: Body: body of request Headers: - test-mode: true Expected: Body: body of request Headers: - test-mode: true -----------------------------","title":"Test Kit"},{"location":"test-kit/#ikor-sip-test-kit","text":"IKOR SIP Test Kit Description Features Response validation External endpoint mocking Endpoint reports Endpoint validation Reports How to use Defining a Test Case when-execute with-mocks then-expect Complete example","title":"IKOR SIP Test Kit"},{"location":"test-kit/#description","text":"SIP Test Kit is a testing system designed to work with SIP integration adapters. It's main purpose is to test how an adapter works internally, by mocking all external communication. It executes a test workflow that is defined in a specific file format, providing a possibility to create tests without code change. This file format is referred to as TestCaseDefinition . The flow itself and thus the TestCaseDefinition file is split into three phases (sections) when-execute - The test is executed by triggering one of adapter's endpoints with-mocks - External calls which are to be replaced with predefined mock behaviour then-expect - The test outcome that should be compared with a predefined expected outcome","title":"Description"},{"location":"test-kit/#features","text":"","title":"Features"},{"location":"test-kit/#response-validation","text":"Major feature of Test Kit is validation of the response from test execution. By adding a validation definition inside the then-expect section and setting that validation for the endpoint we defined in when-execute section, the response of the execution will be validated and a report will be displayed.","title":"Response validation"},{"location":"test-kit/#external-endpoint-mocking","text":"This feature is active whenever a test is executed via test kit. It will provide default behavior (forwarding the request without processing it) and mock all external endpoints. Adding specific behavior for each endpoint can be done in test case definition in 'with-mocks' section.","title":"External endpoint mocking"},{"location":"test-kit/#endpoint-reports","text":"Test Kit will provide reports for all mocked endpoints, both with default (set by Test Kit) and user defined behavior. For each test report in the 'Endpoints' section there will be an overview of request that each received.","title":"Endpoint reports"},{"location":"test-kit/#endpoint-validation","text":"It is possible to also validate body and headers of each mocked endpoint. By defining desired validation inside test case definition file, Test Kit will validate endpoints and display reports for each.","title":"Endpoint validation"},{"location":"test-kit/#reports","text":"As mentioned each test case will be executed as its own unit test, so for each a test report will be generated and printed in console. First part of report is for the response. It will display the validated body and headers, as well as expected ones. The following endpoints part is for mocked endpoint reports, with similar data as in the first part.","title":"Reports"},{"location":"test-kit/#how-to-use","text":"Test kit is enabled by default when the adapter is generated from archetype. A test class needs to be created inside test package of the adapter, which extends SIPBatchTest. Running this class would execute the test, but also it will be executed during build time. public class TFWTest extends SIPBatchTest { } Also, configuring spring profile is needed. Provide the following configuration property inside your test resources. spring: profiles: active: test The next step is to provide the TestCaseDefinition file in yaml format in the test/resources package (detailed description in next section): test-case-definitions: - title: \"Title of individual test\" when-execute: endpoint: \"id of endpoint under test\" with: body: \"Content that will be send as request body to the adapter endpoint (plain text, JSON String)\" headers: header-key: \"Value of the header\" another-header-key: \"Another value\" with-mocks: - endpoint: \"id of endpoint that should be mocked\" returning: body: \"Response message that real endpoint is expected to return\" then-expect: - endpoint: \"id of endpoint under test\" # matches endpoint under test defined in when phase having: body: \"Regex expression (java) which will be compered to the reponse of the test\" headers: header-key: \"Regex expression (java) which will be compered to the value of this header key\" - endpoint: \"id of endpoint that is mocked\" # matches endpoint with defined or default mocked behavior having: body: \"Regex expression (java) which will be compered to the request which arrived on the endpoint\" headers: header-key: \"Regex expression (java) which will be compered to the header key value from request which arrived on the endpoint\" You also need to provide the location of TestCaseDefinition file to the Test Kit by setting the following property inside adapter configuration: sip.testkit.test-cases-path: myTests.yml The default value is test-case-definition.yml, so you can place your test case description under that file, and skip additional setting. Each test case will execute as a separate unit test with its own report displayed. To disable SIP Test Kit, the following configuration is needed: sip: testkit: enabled: false To be able to fully utilize the Test Kit, all the endpoints used in the test case need to have a defined ID which will be referenced in the endpoint parameter of the test case.","title":"How to use"},{"location":"test-kit/#defining-a-test-case","text":"The TestCaseDefinition file starts with test-case-definitions property, which consists of a list of test cases","title":"Defining a Test Case"},{"location":"test-kit/#when-execute","text":"In this section a request that should be sent to the adapter is defined. \"endpoint\" refers to ID (routeId in camel routes) of the endpoint to which we wish to send a test request. In \"with\" part we define content of the request we wish to send, meaning body and headers are added here. The body can also be defined as plain text or JSON string, which represents a POJO. when-execute: endpoint: \"rest-endpoint\" with: body: \"body of request\"","title":"when-execute"},{"location":"test-kit/#with-mocks","text":"This section contains a list of endpoints for which we wish to have specific mocked behavior. \"endpoint\" is the endpoint ID, (processor ID in camel route) of the mocked endpoint. \"returning\" should have the body, that we expect as the response from real external call. with-mocks: - endpoint: \"external-service\" returning: body: \"response message from service\"","title":"with-mocks"},{"location":"test-kit/#then-expect","text":"Validation of test response is defined by setting the \"endpoint\" parameter to the ID of endpoint under test and defining the expected body or headers. Also, validation of requests, which mocks received, is defined by setting the \"endpoint\" parameter to the ID of mocked endpoint and defining the expected body or headers. Body and header validation is possible by either defining regex (Java) expression or matching exact String content. then-expect: - endpoint: \"rest-endpoint\" # matches endpoint under test having: body: \"response .* from service\" headers: CamelHttpResponseCode: \"200\" - endpoint: \"external-service\" # matches endpoint with mocked behavior having: body: \"body of request\" headers: test-mode: \"true\"","title":"then-expect"},{"location":"test-kit/#complete-example","text":"Sample Route public class SampleRestRoute extends RouteBuilder { public void configure() throws Exception { restConfiguration().component(\"servlet\").port(\"8080\").host(\"localhost\"); // Endpoint under test from(\"rest:POST:/say/hello\").routeId(\"rest-endpoint\").to(\"sipmc:bridge\"); from(\"sipmc:bridge\") .routeId(\"http-route\") // Mocked endpoint .to(\"http:localhost:8081/hello?bridgeEndpoint=true\") .id(\"external-service\"); } } Sample test case definition test-case-definitions: - title: \"Test case 1\" when-execute: endpoint: \"rest-endpoint\" # id of endpoint under test (routeId) with: body: \"body of request\" with-mocks: - endpoint: \"external-service\" # id of endpoint that is mocked (processorId) returning: body: \"response message from service\" then-expect: - endpoint: \"rest-endpoint\" # matches endpoint under test having: body: \"response .* from service\" headers: CamelHttpResponseCode: \"200\" - endpoint: \"external-service\" # matches endpoint with mocked behavior having: body: \"body of request\" headers: test-mode: \"true\" Sample Console Report ----------------------------- | SIP Test Execution Report | ----------------------------- Test \"Test case 1\" executed successfully. Validation details: Body validation successful Header validation successful Actual response: Body: response message from service Validated headers: - CamelHttpResponseCode: 200 Expected response: Body: response .* from service Headers: - CamelHttpResponseCode: 200 Endpoints: Endpoint \"external-service\" was mocked Validation successful Received: Body: body of request Headers: - test-mode: true Expected: Body: body of request Headers: - test-mode: true -----------------------------","title":"Complete example"}]}
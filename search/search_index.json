{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"System Integration Platform Framework \u00b6 The System Integration Platform (SIP) Framework is an IKOR product developed from 10 project years of experience with standardized integration of core and peripheral systems. The framework enables building light-weight integration adapters to achieve a technical and non-technical decoupling of systems, using microservices and is therefore highly scalable. It builds on Apache Camel Framework and extends it with a lot of usable features to create a standardized integration approach for all adapters. System Integration Platform Framework What is SIP Usage Framework components Framework features Getting started How and why to use SIP Middle Component Adding additional Camel starters to the project Adding new System Connectors Development Tips Configuration properties What is SIP \u00b6 S ystem I ntegration P latform is a combination of SIP framework, SIP management application and various implementation guidelines and best practices. Combined they create an advantage when developing microservice integration adapters. SIP adapters are specially designed as middleware integrators of specific subdomains of an enterprise. SIP project structure and implementation guidelines provide higher degree of code consistency across different adapter instances, making them much easier to maintain, manage and monitor. The goal is to have minimal set of restrictions of developer's freedom with maximum comfort and efficiency while developing. To start developing with SIP, we should first get familiar with its basic concepts. Let's take a very simple scenario as an example. Say we have two systems working on the same domain (Partner, Policy, Billing etc.), but they were never designed to work together, and suddenly there is a need to connect them. Both systems expose APIs, which are mutually not compatible, both by data model and/or communication technology they use. SIP is designed as a standalone middleware app with a sole purpose to resolve exactly this kind of problems in a flexible and standardized way. Actual integration scenarios may include more than two APIs, or even more than two systems, but all the principles apply equally to such scenarios. The image below shows the modules structure of a single SIP adapter. To provide a level of flexibility, SIP splits the problem into two, giving the possibility to develop and/or deploy connectors for individual systems separately. The integration logic is divided into three modules: System A - Connector , System B - Connector and Domain . The fourth module is the Application module. Its purpose is to converge the three integration modules into one deployable and executable application. The blue arrows represent dependencies of the application module. Domain The Domain module takes a central position in the image, because it provides the common data model for both systems. Also, it separates the system connectors from each other to allow loose coupling between them. It should not contain any integration logic but only simple Java objects representing the respective domain in which the system connectors of an adapter operate. All connectors should adapt the data models of their systems to or from this common model, depending on data flow, due to their incompatibilities. The domain can be seen as a kind of contract between the different system connectors which ensures that they can communicate with each other. It contains common data model which uniforms the data models from all integration sides. Connectors Connectors are designed to communicate with the associated external systems, thus all classes found in a connector should only relate to their integration side. To enable this, their local domain objects are aligned with the API of an external systems they communicate with. In order to send a message from one system connector to another, the local domain objects must be mapped to the shared domain object. Furthermore, this means that a message from system A is mapped to the shared domain object and then from the shared domain object to the model of system B and vice versa, due to their bidirectional nature. Notice the blue arrows pointing from the system connectors to the domain module, meaning that connectors are absolutely independent of each other. A developer can work on or deploy only one side, without the others being affected. This also means that changes on one of adapter's connector does not necessarily require changes of the other. That's especially important if the affected connector is reused across multiple adapters. In the picture domain A and domain B packages are shown optionally, together with corresponding mapper component, since integrated systems use the same communication data model sometimes. Each connector will have the following structure: config a place for any configuration classes sink here we should define Camel routes transformers it should contain classes for adapting the connector model to common domain model. domain (optional) it may contain the data model of the system. Application The Application module gathers all connector modules as one system and run them together. Starting your adapter is done by running SIPApplication class in the application module. Furthermore, its pom.xml must contain dependencies to all connector modules in adapter, in order to start them. This module should not contain any integration logic, but it's a good place for implementing Spring integration tests, such as default SIPApplicationTest, provided by archetype. Usage \u00b6 Framework components \u00b6 sip-archetype - Archetype creates a basic SIP Adapter project with a defined structure and necessary dependencies. Project is created by executing single maven command. sip-core - Core project for base SIP functionalities. sip-middle-component - Custom Camel component used as abstracted connector between different integration sides. sip-integration-starter - Starter project adding necessary predefined dependencies for integration adapters. sip-starter-parent - This project takes care of versions for Spring Boot and Camel dependencies. sip-security - Security in SIP framework. The following image displays how listed modules are utilized on SIP adapter where the up arrows represent inheritance, down arrows dependencies. Framework features \u00b6 Framework provides different features some of which are enabled by default. All the features are customizable and can be overwritten or turned off by configuration. More about how to use them you can find under the corresponding module's documentation. Actuator health check and metrics - Out-of-the-box health checks for HTTP(S), JMS and FTP, SFTP and FTPS endpoints. Proxy for Apache Camel Processors - Proxies for Apache Camel processors with process and mock functionalities. Working with routes in runtime - Dynamical changing routes lifecycle. Logging Translation - Translation of logging messages. Changing log level programmatically - Dynamical changing of log level. Exchange tracing - Tracing and storing exchanges on Camel Processor level. OpenAPI Descriptor - Built-in OpenAPI. SIP Middle component publish-subscribe - Multiple consumers on middle component. SIP Security - Includes SSL setup, base and x509 authentication Getting started \u00b6 Before development, check the following Installation guide . Once you have your adapter you can do the following steps: Run mvn clean install Crate common Data Model inside domain module Add necessary dependencies to each module Add RouteBuilders inside \"sink\" package in connectors Add classes which transform system data models to or from common domain model in \"transformers\" package in connectors (if needed) Add any configuration classes for a specific system inside \"config\" package in connectors Add general integration configuration in application.yml found inside application module resources Run SIPApplication found inside application module After the application is up and running you can check SIP's management API under localhost:8080/swagger-ui.html How and why to use SIP Middle Component \u00b6 SIP Middle Component (sipmc) is a key concept of SIP Framework. As such it is used as a communication device between connectors. To make a clear distinction between connectors, the point of separation can be seen with sipmc. It marks the end or beginning of integration sides. Currently, sipmc works as either 1 to 1 connector or publish subscribe, based on the number of consumers, without any additional configuration. Adding additional Camel starters to the project \u00b6 The Maven dependency management techniques implemented in the SIP archetype give you the ability to easily add new camel-starter dependencies to integration adapters. Should you need additional Apache Camel Components in the project, it is enough to add their Spring Boot starter dependency, without version number - as it is managed in the parent Maven module of the SIP integration adapter. For instance, to add ArangoDb Camel component, it is enough to add the following dependency to the project: <dependency> <groupId>org.apache.camel.springboot</groupId> <artifactId>camel-arangodb-starter</artifactId> </dependency> The same stands for adding Spring Boot starters - as they are managed in the parent Maven module they too can be added without explicitly stating version numbers. As a matter of fact, the overall dependency management performed by the Spring Boot is in place in integration adapters too. However, if you need to use some third-party libraries - there are chances that you will be responsible for managing their versions in the application. It is important to add the required dependency to the corresponding connector module's pom. Only that way connector modules can keep their independence. Adding new System Connectors \u00b6 By using the SIP archetype to create a new SIP adapter, by default there are two system connectors, designed to make it more convenient to integrate systems. In case there are more than two systems, which need to be integrated, you need to add additional modules to the project structure. There are a number of ways to add new system connectors to a SIP adapter. These possibilities are explained in detail in the following part. Initially each system connector module has two dependencies. These are the domain module and the sip-integration-starter . Make sure to add these to your pom.xml dependencies list. Please observe this exemplary pom.xml to see how it should look like in a system connector module. The module structure usually looks like this: fancy-sip-adapter \u251c\u2500\u2500\u2500new-system-connector-module \u2502 \u251c\u2500\u2500\u2500src/main/java/<package-path> \u2502 \u2502 \u251c\u2500\u2500\u2500config \u2502 \u2502 \u251c\u2500\u2500\u2500sink \u2502 \u2502 \u2514\u2500\u2500\u2500transformer \u2502 \u2514\u2500\u2500\u2500pom.xml ... Copying Existing Module One way to add a system connector as a new module is to copy an existing module, that has been created by using the SIP archetype to your project structure. If the module was copied the name and artifactId in its pom.xml need to be adjusted. Then the module name should be added to the modules element of the pom.xml of the main project. <modules> <module>system-connector-A</module> <module>system-connector-B</module> <module>new-system-connector-module</module> </modules> Additionally, the copied module must be added as a dependency to the pom.xml of the application module. <dependencies> <dependency> <groupId>de.ikor.sip.adapter</groupId> <artifactId>new-system-connector-module</artifactId> <version>${project.version}</version> </dependency> ... </dependencies> If necessary, refresh or rebuild the project so that the newly created module gets registered. Using IDEs Built-In Functionality IntelliJ Right click on the parent project folder and select New > Module... . Select Maven in the left menu and click on the Next button Provide a new module name and click on Finish Eclipse File > New > Other... Enter maven module select Maven Module from the search result list and click on Next Enter a module name select the parent project and press Next Choose a maven archetype version from the list and click Next (You can use the default selection) Check the archetype parameters and press Finish The result is a new subdirectory of the SIP adapter project. Compare the pom.xml of the newly created module with one of the modules that were created by SIP archetype. There are only a few differences that need to be adjusted. Make sure the newly created module is present in the modules element list of the main pom.xml and that it has been added as a dependency to the application pom.xml . Example POM <?xml version=\"1.0\" encoding=\"UTF-8\"?> <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"> <modelVersion>4.0.0</modelVersion> <parent> <groupId>de.ikor.sip.adapter</groupId> <artifactId>systemadapter</artifactId> <version>1.0-SNAPSHOT</version> </parent> <artifactId>outbound</artifactId> <name>outbound</name> <dependencies> <dependency> <groupId>de.ikor.sip.foundation</groupId> <artifactId>sip-integration-starter</artifactId> </dependency> <dependency> <groupId>de.ikor.sip.adapter</groupId> <artifactId>systemadapter-domain</artifactId> </dependency> </dependencies> </project> Development Tips \u00b6 Endpoint Configuration When it comes to working with URIs in routes, it is recommended to use property placeholders, which makes the routes configurable. Additionally, it would make much sense to follow suggested configuration convention for defining endpoint configuration. endpoint: <in/out>: <adapter-name>: <external-system>: <endpoint>: # optional - if more endpoints on single external-system are involved in integration id: <adapterName>.<externalSystem> uri: ftp://... \\ corresponds to consumers and producers respectively. This means in case a message is received through a route using \"from\", then it is a consumer and \"in\" is used. On the other hand, it is a producer when a message is sent via \"to\". In this case, \"out\" is used as key in the configuration file. \\ should correspond to the domain adapter it is dealing with (e.g. billing, partner, policy etc.) \\ should match the name of the system or client the adapter is communicating with. \\ in case there are multiple endpoints for an adapter that uses the same domain and external system, additional identification is required. For this purpose we use an additional endpoint key to provide distinction. For example: endpoint: in: partner: my-assurance-co: id: partner.my-assurance-co uri: ftp://... out: partner: their-assurance-co: id: partner.their-assurance-co uri: https://... Using this configuration can be easily achieved in Camel by following their placeholder syntax. Here's what the example from above would look like in the Camel route: from(\"{{endpoint.in.partner.my-assurance-co.uri}}\") .id(\"{{endpoint.in.partner.my-assurance-co.id}}\") .to(...); from(...) .process(...) .to(\"{{endpoint.out.partner.their-assurance-co.uri}}\") .id(\"{{endpoint.out.partner.their-assurance-co.id}}\") If this convention is followed in the configuration, it leads to a unified structure that makes it possible to identify at a single glance which systems are communicating with each other and which communication technologies are being used. It also makes routes more descriptive and adapters much easier to maintain. Setting processor and route IDs As we can see each external endpoint, definition is followed by explicit setting of id. Although it's not mandatory, doing so is highly recommended especially in case of outgoing endpoints. This will provide a reference of the external endpoints, which can be used for different functionalities, like mocking, custom health check or other functionalities that are yet to come. Notice that in case of incoming endpoints (those in \"from\" statement), following id refers to the routeId. Configuration properties \u00b6 By default, the following properties come as a part of SIP Framework, to override them simply add them to your configuration file with desired values. When using a yaml configuration file, which is already available in application module, adapt the properties to its format. Name Description Value Default sip.core.translation.fileLocations Sets locations of translation bundles List classpath:translations/translated-messages, classpath:translations/sip-core-messages sip.core.translation.default-encoding Sets default encoding String UTF-8 sip.core.translation.fallback-to-system-locale Use system language if none defined boolean false sip.core.translation.use-code-as-default-message If key is not assigned use it in message boolean true sip.core.translation.lang Set language of log messages String en sip.core.tracing.enabled Enable SIP tracing and trace history boolean true sip.core.tracing.limit Sets storage limit in trace history number 100 sip.core.tracing.exchange-formatter.{property-name} Sets value for specific property in ExchangeFormatter / / management.endpoint.health.show-details Enable health details in actuator String always management.endpoints.web.exposure.include Set which endpoints are included String health,info,metrics,loggers,prometheus springdoc.show-actuator Show actuator API in Swagger docs boolean true springdoc.api-docs.path Custom path to API docs String /api-docs springdoc.swagger-ui.path Custom path to Swagger String /swagger-ui.html springdoc.swagger-ui.disable-swagger-default-url Disables default petstore API in swagger boolean true springdoc.api-docs.enabled Enable/Disable API docs boolean true springdoc.swagger-ui.enabled Enable/Disable swagger boolean true logging.level.root Sets the default log level String INFO","title":"Introduction"},{"location":"#system-integration-platform-framework","text":"The System Integration Platform (SIP) Framework is an IKOR product developed from 10 project years of experience with standardized integration of core and peripheral systems. The framework enables building light-weight integration adapters to achieve a technical and non-technical decoupling of systems, using microservices and is therefore highly scalable. It builds on Apache Camel Framework and extends it with a lot of usable features to create a standardized integration approach for all adapters. System Integration Platform Framework What is SIP Usage Framework components Framework features Getting started How and why to use SIP Middle Component Adding additional Camel starters to the project Adding new System Connectors Development Tips Configuration properties","title":"System Integration Platform Framework"},{"location":"#what-is-sip","text":"S ystem I ntegration P latform is a combination of SIP framework, SIP management application and various implementation guidelines and best practices. Combined they create an advantage when developing microservice integration adapters. SIP adapters are specially designed as middleware integrators of specific subdomains of an enterprise. SIP project structure and implementation guidelines provide higher degree of code consistency across different adapter instances, making them much easier to maintain, manage and monitor. The goal is to have minimal set of restrictions of developer's freedom with maximum comfort and efficiency while developing. To start developing with SIP, we should first get familiar with its basic concepts. Let's take a very simple scenario as an example. Say we have two systems working on the same domain (Partner, Policy, Billing etc.), but they were never designed to work together, and suddenly there is a need to connect them. Both systems expose APIs, which are mutually not compatible, both by data model and/or communication technology they use. SIP is designed as a standalone middleware app with a sole purpose to resolve exactly this kind of problems in a flexible and standardized way. Actual integration scenarios may include more than two APIs, or even more than two systems, but all the principles apply equally to such scenarios. The image below shows the modules structure of a single SIP adapter. To provide a level of flexibility, SIP splits the problem into two, giving the possibility to develop and/or deploy connectors for individual systems separately. The integration logic is divided into three modules: System A - Connector , System B - Connector and Domain . The fourth module is the Application module. Its purpose is to converge the three integration modules into one deployable and executable application. The blue arrows represent dependencies of the application module. Domain The Domain module takes a central position in the image, because it provides the common data model for both systems. Also, it separates the system connectors from each other to allow loose coupling between them. It should not contain any integration logic but only simple Java objects representing the respective domain in which the system connectors of an adapter operate. All connectors should adapt the data models of their systems to or from this common model, depending on data flow, due to their incompatibilities. The domain can be seen as a kind of contract between the different system connectors which ensures that they can communicate with each other. It contains common data model which uniforms the data models from all integration sides. Connectors Connectors are designed to communicate with the associated external systems, thus all classes found in a connector should only relate to their integration side. To enable this, their local domain objects are aligned with the API of an external systems they communicate with. In order to send a message from one system connector to another, the local domain objects must be mapped to the shared domain object. Furthermore, this means that a message from system A is mapped to the shared domain object and then from the shared domain object to the model of system B and vice versa, due to their bidirectional nature. Notice the blue arrows pointing from the system connectors to the domain module, meaning that connectors are absolutely independent of each other. A developer can work on or deploy only one side, without the others being affected. This also means that changes on one of adapter's connector does not necessarily require changes of the other. That's especially important if the affected connector is reused across multiple adapters. In the picture domain A and domain B packages are shown optionally, together with corresponding mapper component, since integrated systems use the same communication data model sometimes. Each connector will have the following structure: config a place for any configuration classes sink here we should define Camel routes transformers it should contain classes for adapting the connector model to common domain model. domain (optional) it may contain the data model of the system. Application The Application module gathers all connector modules as one system and run them together. Starting your adapter is done by running SIPApplication class in the application module. Furthermore, its pom.xml must contain dependencies to all connector modules in adapter, in order to start them. This module should not contain any integration logic, but it's a good place for implementing Spring integration tests, such as default SIPApplicationTest, provided by archetype.","title":"What is SIP"},{"location":"#usage","text":"","title":"Usage"},{"location":"#framework-components","text":"sip-archetype - Archetype creates a basic SIP Adapter project with a defined structure and necessary dependencies. Project is created by executing single maven command. sip-core - Core project for base SIP functionalities. sip-middle-component - Custom Camel component used as abstracted connector between different integration sides. sip-integration-starter - Starter project adding necessary predefined dependencies for integration adapters. sip-starter-parent - This project takes care of versions for Spring Boot and Camel dependencies. sip-security - Security in SIP framework. The following image displays how listed modules are utilized on SIP adapter where the up arrows represent inheritance, down arrows dependencies.","title":"Framework components"},{"location":"#framework-features","text":"Framework provides different features some of which are enabled by default. All the features are customizable and can be overwritten or turned off by configuration. More about how to use them you can find under the corresponding module's documentation. Actuator health check and metrics - Out-of-the-box health checks for HTTP(S), JMS and FTP, SFTP and FTPS endpoints. Proxy for Apache Camel Processors - Proxies for Apache Camel processors with process and mock functionalities. Working with routes in runtime - Dynamical changing routes lifecycle. Logging Translation - Translation of logging messages. Changing log level programmatically - Dynamical changing of log level. Exchange tracing - Tracing and storing exchanges on Camel Processor level. OpenAPI Descriptor - Built-in OpenAPI. SIP Middle component publish-subscribe - Multiple consumers on middle component. SIP Security - Includes SSL setup, base and x509 authentication","title":"Framework features"},{"location":"#getting-started","text":"Before development, check the following Installation guide . Once you have your adapter you can do the following steps: Run mvn clean install Crate common Data Model inside domain module Add necessary dependencies to each module Add RouteBuilders inside \"sink\" package in connectors Add classes which transform system data models to or from common domain model in \"transformers\" package in connectors (if needed) Add any configuration classes for a specific system inside \"config\" package in connectors Add general integration configuration in application.yml found inside application module resources Run SIPApplication found inside application module After the application is up and running you can check SIP's management API under localhost:8080/swagger-ui.html","title":"Getting started"},{"location":"#how-and-why-to-use-sip-middle-component","text":"SIP Middle Component (sipmc) is a key concept of SIP Framework. As such it is used as a communication device between connectors. To make a clear distinction between connectors, the point of separation can be seen with sipmc. It marks the end or beginning of integration sides. Currently, sipmc works as either 1 to 1 connector or publish subscribe, based on the number of consumers, without any additional configuration.","title":"How and why to use SIP Middle Component"},{"location":"#adding-additional-camel-starters-to-the-project","text":"The Maven dependency management techniques implemented in the SIP archetype give you the ability to easily add new camel-starter dependencies to integration adapters. Should you need additional Apache Camel Components in the project, it is enough to add their Spring Boot starter dependency, without version number - as it is managed in the parent Maven module of the SIP integration adapter. For instance, to add ArangoDb Camel component, it is enough to add the following dependency to the project: <dependency> <groupId>org.apache.camel.springboot</groupId> <artifactId>camel-arangodb-starter</artifactId> </dependency> The same stands for adding Spring Boot starters - as they are managed in the parent Maven module they too can be added without explicitly stating version numbers. As a matter of fact, the overall dependency management performed by the Spring Boot is in place in integration adapters too. However, if you need to use some third-party libraries - there are chances that you will be responsible for managing their versions in the application. It is important to add the required dependency to the corresponding connector module's pom. Only that way connector modules can keep their independence.","title":"Adding additional Camel starters to the project"},{"location":"#adding-new-system-connectors","text":"By using the SIP archetype to create a new SIP adapter, by default there are two system connectors, designed to make it more convenient to integrate systems. In case there are more than two systems, which need to be integrated, you need to add additional modules to the project structure. There are a number of ways to add new system connectors to a SIP adapter. These possibilities are explained in detail in the following part. Initially each system connector module has two dependencies. These are the domain module and the sip-integration-starter . Make sure to add these to your pom.xml dependencies list. Please observe this exemplary pom.xml to see how it should look like in a system connector module. The module structure usually looks like this: fancy-sip-adapter \u251c\u2500\u2500\u2500new-system-connector-module \u2502 \u251c\u2500\u2500\u2500src/main/java/<package-path> \u2502 \u2502 \u251c\u2500\u2500\u2500config \u2502 \u2502 \u251c\u2500\u2500\u2500sink \u2502 \u2502 \u2514\u2500\u2500\u2500transformer \u2502 \u2514\u2500\u2500\u2500pom.xml ... Copying Existing Module One way to add a system connector as a new module is to copy an existing module, that has been created by using the SIP archetype to your project structure. If the module was copied the name and artifactId in its pom.xml need to be adjusted. Then the module name should be added to the modules element of the pom.xml of the main project. <modules> <module>system-connector-A</module> <module>system-connector-B</module> <module>new-system-connector-module</module> </modules> Additionally, the copied module must be added as a dependency to the pom.xml of the application module. <dependencies> <dependency> <groupId>de.ikor.sip.adapter</groupId> <artifactId>new-system-connector-module</artifactId> <version>${project.version}</version> </dependency> ... </dependencies> If necessary, refresh or rebuild the project so that the newly created module gets registered. Using IDEs Built-In Functionality IntelliJ Right click on the parent project folder and select New > Module... . Select Maven in the left menu and click on the Next button Provide a new module name and click on Finish Eclipse File > New > Other... Enter maven module select Maven Module from the search result list and click on Next Enter a module name select the parent project and press Next Choose a maven archetype version from the list and click Next (You can use the default selection) Check the archetype parameters and press Finish The result is a new subdirectory of the SIP adapter project. Compare the pom.xml of the newly created module with one of the modules that were created by SIP archetype. There are only a few differences that need to be adjusted. Make sure the newly created module is present in the modules element list of the main pom.xml and that it has been added as a dependency to the application pom.xml . Example POM <?xml version=\"1.0\" encoding=\"UTF-8\"?> <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"> <modelVersion>4.0.0</modelVersion> <parent> <groupId>de.ikor.sip.adapter</groupId> <artifactId>systemadapter</artifactId> <version>1.0-SNAPSHOT</version> </parent> <artifactId>outbound</artifactId> <name>outbound</name> <dependencies> <dependency> <groupId>de.ikor.sip.foundation</groupId> <artifactId>sip-integration-starter</artifactId> </dependency> <dependency> <groupId>de.ikor.sip.adapter</groupId> <artifactId>systemadapter-domain</artifactId> </dependency> </dependencies> </project>","title":"Adding new System Connectors"},{"location":"#development-tips","text":"Endpoint Configuration When it comes to working with URIs in routes, it is recommended to use property placeholders, which makes the routes configurable. Additionally, it would make much sense to follow suggested configuration convention for defining endpoint configuration. endpoint: <in/out>: <adapter-name>: <external-system>: <endpoint>: # optional - if more endpoints on single external-system are involved in integration id: <adapterName>.<externalSystem> uri: ftp://... \\ corresponds to consumers and producers respectively. This means in case a message is received through a route using \"from\", then it is a consumer and \"in\" is used. On the other hand, it is a producer when a message is sent via \"to\". In this case, \"out\" is used as key in the configuration file. \\ should correspond to the domain adapter it is dealing with (e.g. billing, partner, policy etc.) \\ should match the name of the system or client the adapter is communicating with. \\ in case there are multiple endpoints for an adapter that uses the same domain and external system, additional identification is required. For this purpose we use an additional endpoint key to provide distinction. For example: endpoint: in: partner: my-assurance-co: id: partner.my-assurance-co uri: ftp://... out: partner: their-assurance-co: id: partner.their-assurance-co uri: https://... Using this configuration can be easily achieved in Camel by following their placeholder syntax. Here's what the example from above would look like in the Camel route: from(\"{{endpoint.in.partner.my-assurance-co.uri}}\") .id(\"{{endpoint.in.partner.my-assurance-co.id}}\") .to(...); from(...) .process(...) .to(\"{{endpoint.out.partner.their-assurance-co.uri}}\") .id(\"{{endpoint.out.partner.their-assurance-co.id}}\") If this convention is followed in the configuration, it leads to a unified structure that makes it possible to identify at a single glance which systems are communicating with each other and which communication technologies are being used. It also makes routes more descriptive and adapters much easier to maintain. Setting processor and route IDs As we can see each external endpoint, definition is followed by explicit setting of id. Although it's not mandatory, doing so is highly recommended especially in case of outgoing endpoints. This will provide a reference of the external endpoints, which can be used for different functionalities, like mocking, custom health check or other functionalities that are yet to come. Notice that in case of incoming endpoints (those in \"from\" statement), following id refers to the routeId.","title":"Development Tips"},{"location":"#configuration-properties","text":"By default, the following properties come as a part of SIP Framework, to override them simply add them to your configuration file with desired values. When using a yaml configuration file, which is already available in application module, adapt the properties to its format. Name Description Value Default sip.core.translation.fileLocations Sets locations of translation bundles List classpath:translations/translated-messages, classpath:translations/sip-core-messages sip.core.translation.default-encoding Sets default encoding String UTF-8 sip.core.translation.fallback-to-system-locale Use system language if none defined boolean false sip.core.translation.use-code-as-default-message If key is not assigned use it in message boolean true sip.core.translation.lang Set language of log messages String en sip.core.tracing.enabled Enable SIP tracing and trace history boolean true sip.core.tracing.limit Sets storage limit in trace history number 100 sip.core.tracing.exchange-formatter.{property-name} Sets value for specific property in ExchangeFormatter / / management.endpoint.health.show-details Enable health details in actuator String always management.endpoints.web.exposure.include Set which endpoints are included String health,info,metrics,loggers,prometheus springdoc.show-actuator Show actuator API in Swagger docs boolean true springdoc.api-docs.path Custom path to API docs String /api-docs springdoc.swagger-ui.path Custom path to Swagger String /swagger-ui.html springdoc.swagger-ui.disable-swagger-default-url Disables default petstore API in swagger boolean true springdoc.api-docs.enabled Enable/Disable API docs boolean true springdoc.swagger-ui.enabled Enable/Disable swagger boolean true logging.level.root Sets the default log level String INFO","title":"Configuration properties"},{"location":"CODE_OF_CONDUCT/","text":"Contributor Code of Conduct \u00b6 As contributors and maintainers of this project, and in the interest of fostering an open and welcoming community, we pledge to respect all people who contribute through reporting issues, posting feature requests, updating documentation, submitting pull requests or patches, and other activities. We are committed to making participation in this project a harassment-free experience for everyone, regardless of level of experience, gender, gender identity and expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion, or nationality. Examples of unacceptable behavior by participants include: The use of sexualized language or imagery Personal attacks Trolling or insulting/derogatory comments Public or private harassment Publishing other's private information, such as physical or electronic addresses, without explicit permission Other unethical or unprofessional conduct Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. By adopting this Code of Conduct, project maintainers commit themselves to fairly and consistently applying these principles to every aspect of managing this project. Project maintainers who do not follow or enforce the Code of Conduct may be permanently removed from the project team. This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting a project maintainer at code-of-conduct@ikor.de. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. Maintainers are obligated to maintain confidentiality with regard to the reporter of an incident. This Code of Conduct is adapted from the Contributor Covenant , version 1.3.0, available at contributor-covenant.org/version/1/3/0/","title":"Code Of Conduct"},{"location":"CODE_OF_CONDUCT/#contributor-code-of-conduct","text":"As contributors and maintainers of this project, and in the interest of fostering an open and welcoming community, we pledge to respect all people who contribute through reporting issues, posting feature requests, updating documentation, submitting pull requests or patches, and other activities. We are committed to making participation in this project a harassment-free experience for everyone, regardless of level of experience, gender, gender identity and expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion, or nationality. Examples of unacceptable behavior by participants include: The use of sexualized language or imagery Personal attacks Trolling or insulting/derogatory comments Public or private harassment Publishing other's private information, such as physical or electronic addresses, without explicit permission Other unethical or unprofessional conduct Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. By adopting this Code of Conduct, project maintainers commit themselves to fairly and consistently applying these principles to every aspect of managing this project. Project maintainers who do not follow or enforce the Code of Conduct may be permanently removed from the project team. This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting a project maintainer at code-of-conduct@ikor.de. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. Maintainers are obligated to maintain confidentiality with regard to the reporter of an incident. This Code of Conduct is adapted from the Contributor Covenant , version 1.3.0, available at contributor-covenant.org/version/1/3/0/","title":"Contributor Code of Conduct"},{"location":"CONTRIBUTING/","text":"Contributing to SIP \u00b6 Contributing to SIP Code of conduct How can I contribute Reporting bugs Reporting security vulnerabilities Requesting features Pull requests (to get YOUR contribution merged) Guidelines Coding Pull request process First off, thanks for your contribution! \ud83d\udc4d SIP is released under the Apache 2.0 license. If you would like to contribute you are very welcome to do so and this document should help you having a good start. Please note we have a code of conduct, please follow it in all your interactions with the project. Code of conduct \u00b6 This project adheres to the Contributor Covenant code of conduct . By participating, you are expected to uphold this code. Please report unacceptable behavior to the given email address. How can I contribute \u00b6 Reporting bugs \u00b6 We use GitHub issues to track bugs. Bug reports should be done by using and completing the bug tracking template. Please handle possibly security vulnerabilities with special care as described below. Reporting security vulnerabilities \u00b6 If you think you have found a security vulnerability please DO NOT disclose it publicly until we've had a chance to fix it as this may result in an unnecessary security threat. We will handle these requests with special care. Please contact us with templated bug report via email at: opensource@ikor.de Requesting features \u00b6 Feature requests can be done by creating a Github Issue using the feature request template. Pull requests (to get YOUR contribution merged) \u00b6 Another option to contribute is to fix any bugs from the bug list, implement features, extend functionality, adapt the documentation or whatever else you can imagine! \ud83d\udc4d To get your adaptions merged you need to create a pull request. You have to complete the provided pull request template. We will take care of the submitted pull requests and to mention this once again: Thank you very much for your contribution! Guidelines \u00b6 We welcome everyones work and engagement to evolve SIP. To make our life easier and we defined a couple of guidelines to follow while working on the code and we ask everyone to adhere to these points. During the pull request process the reviewer will check if the pull request adheres to the following rules. The rules are questions you should answer before creating a pull request: Coding \u00b6 Have you avoided to use field based autowiring? (see here why we chose to use constructor autowiring) Are all your unit tests written with junit5 and assertions with assertj ( see )? Does your code not add any new compile warnings? Does your contribution contain necessary and useful javadoc and is the linting process successful? Is the maven project version a SNAPSHOT version? Are all dependencies you added RELEASE versions? Did you change something in the documentation? Then run ./run-mkdocs-server.sh and check that your changes look good (mkdocs server will be running on port 8000) Pull request process \u00b6 Does your contribution follow the Google Java Coding style? (you can find it here ) Does your pull request only contain changes related to the topic the branch was intended for? Does your pull request contain useful and necessary tests? Was the Sonarqube analysis of your PR successful and all quality gates are met? Have you added a complete, valid and self explaining changelog? Changelogs have to be put into one of these folders: changelogs/bugfix , changelogs/documentation , changelogs/feature , changelogs/major The name of the changelog file has to end with the suffix .json The format of a changelog file is as follow (don't copy the comments, only the real json key-value pairs): { # put your github username here \"author\": \"stieglma\", # put the id of the pull request here (yes that means you will need to create the pull # request before you can finish writing the changelog entry) \"pullrequestId\": 1, # put a precise and short description of your changes here \"message\": \"Update documentation, add information about changelog entries for contributors\", # issue id is optional, there may be pull requests without related issues, # so this field can be left out if necessary \"issue\": \"123\" } Is your pull request mergeable? Was your branch deleted after merging the sources? Does the pull request also contain necessary documentation changes or adaptions Have you used and completed the pull request form provided?","title":"Contribution Guidelines"},{"location":"CONTRIBUTING/#contributing-to-sip","text":"Contributing to SIP Code of conduct How can I contribute Reporting bugs Reporting security vulnerabilities Requesting features Pull requests (to get YOUR contribution merged) Guidelines Coding Pull request process First off, thanks for your contribution! \ud83d\udc4d SIP is released under the Apache 2.0 license. If you would like to contribute you are very welcome to do so and this document should help you having a good start. Please note we have a code of conduct, please follow it in all your interactions with the project.","title":"Contributing to SIP"},{"location":"CONTRIBUTING/#code-of-conduct","text":"This project adheres to the Contributor Covenant code of conduct . By participating, you are expected to uphold this code. Please report unacceptable behavior to the given email address.","title":"Code of conduct"},{"location":"CONTRIBUTING/#how-can-i-contribute","text":"","title":"How can I contribute"},{"location":"CONTRIBUTING/#reporting-bugs","text":"We use GitHub issues to track bugs. Bug reports should be done by using and completing the bug tracking template. Please handle possibly security vulnerabilities with special care as described below.","title":"Reporting bugs"},{"location":"CONTRIBUTING/#reporting-security-vulnerabilities","text":"If you think you have found a security vulnerability please DO NOT disclose it publicly until we've had a chance to fix it as this may result in an unnecessary security threat. We will handle these requests with special care. Please contact us with templated bug report via email at: opensource@ikor.de","title":"Reporting security vulnerabilities"},{"location":"CONTRIBUTING/#requesting-features","text":"Feature requests can be done by creating a Github Issue using the feature request template.","title":"Requesting features"},{"location":"CONTRIBUTING/#pull-requests-to-get-your-contribution-merged","text":"Another option to contribute is to fix any bugs from the bug list, implement features, extend functionality, adapt the documentation or whatever else you can imagine! \ud83d\udc4d To get your adaptions merged you need to create a pull request. You have to complete the provided pull request template. We will take care of the submitted pull requests and to mention this once again: Thank you very much for your contribution!","title":"Pull requests (to get YOUR contribution merged)"},{"location":"CONTRIBUTING/#guidelines","text":"We welcome everyones work and engagement to evolve SIP. To make our life easier and we defined a couple of guidelines to follow while working on the code and we ask everyone to adhere to these points. During the pull request process the reviewer will check if the pull request adheres to the following rules. The rules are questions you should answer before creating a pull request:","title":"Guidelines"},{"location":"CONTRIBUTING/#coding","text":"Have you avoided to use field based autowiring? (see here why we chose to use constructor autowiring) Are all your unit tests written with junit5 and assertions with assertj ( see )? Does your code not add any new compile warnings? Does your contribution contain necessary and useful javadoc and is the linting process successful? Is the maven project version a SNAPSHOT version? Are all dependencies you added RELEASE versions? Did you change something in the documentation? Then run ./run-mkdocs-server.sh and check that your changes look good (mkdocs server will be running on port 8000)","title":"Coding"},{"location":"CONTRIBUTING/#pull-request-process","text":"Does your contribution follow the Google Java Coding style? (you can find it here ) Does your pull request only contain changes related to the topic the branch was intended for? Does your pull request contain useful and necessary tests? Was the Sonarqube analysis of your PR successful and all quality gates are met? Have you added a complete, valid and self explaining changelog? Changelogs have to be put into one of these folders: changelogs/bugfix , changelogs/documentation , changelogs/feature , changelogs/major The name of the changelog file has to end with the suffix .json The format of a changelog file is as follow (don't copy the comments, only the real json key-value pairs): { # put your github username here \"author\": \"stieglma\", # put the id of the pull request here (yes that means you will need to create the pull # request before you can finish writing the changelog entry) \"pullrequestId\": 1, # put a precise and short description of your changes here \"message\": \"Update documentation, add information about changelog entries for contributors\", # issue id is optional, there may be pull requests without related issues, # so this field can be left out if necessary \"issue\": \"123\" } Is your pull request mergeable? Was your branch deleted after merging the sources? Does the pull request also contain necessary documentation changes or adaptions Have you used and completed the pull request form provided?","title":"Pull request process"},{"location":"archetype/","text":"IKOR SIP Archetype \u00b6 IKOR SIP Archetype Description How to create a SIP Adapter using SIP Archetype Description \u00b6 This archetype creates a basic SIP Adapter project with a defined structure and necessary dependencies How to create a SIP Adapter using SIP Archetype \u00b6 In order to make setting up a new integration adapter project an easy task, we have created a dedicated SIP (Adapter) Maven archetype, that gives the ability to quickly bootstrap a new integration adapter, along with all needed Maven dependencies and goodies, as well as the recommended, preferred organization of the project. To make a long story short, you can create a SIP Adapter by using the following Maven command: mvn archetype:generate \\ -DarchetypeGroupId=de.ikor.sip.foundation \\ -DarchetypeArtifactId=sip-archetype \\ -DarchetypeVersion=<latest.sip-archetype.version> \\ -DgroupId=de.ikor.sip.adapter \\ -DartifactId=demo \\ -DprojectName=DemoAdapter \\ -Dversion=1.0.0-SNAPSHOT When executing the command, pay attention to use the latest archetype version for the -DarchetypeVersion parameter. The parameters -DgroupId , -DartifactId , -DprojectName and -Dversion should be adjusted to better match your project, as they set the properties for the adapter. It is recommended to follow the maven naming convention. After executing maven command, you will be requested to insert additional parameters about project structure: packageSuffix is used to create project package name by concatenating its value to the groupId. There is a strict validation for using only lower case letters and it is meant to name the package by extending your groupId for only one word. package (optional) is used to override previous package naming and provide full package name. This can be skipped by leaving value empty. It is strongly recommended to follow package naming convention, otherwise your project will be created but it will consist package naming errors. systemConnector1 / systemConnector2 are representing names of your connector modules inside the project. Naming recommendation is to use lower case letters and kebab-case. systemConnector1Package / systemConnector2Package are used to define package name suffix for the connectors. Notice that connector package name starts with prefix defined on package step. After a successful build, a project with the 4 following modules will be created: {artifactId}-application {artifactId}-domain {systemConnector1} {systemConnector2} Our recommendation for modules naming is shown on the following Partner Adapter example: partner-adapter-application partner-adapter-domain partner-connector-{arbitrary connector1 name} partner-connector-{arbitrary connector2 name} More about modules and internal SIP structure you can find here . More information about Maven archetypes is available here: Maven Archetype","title":"Archetype"},{"location":"archetype/#ikor-sip-archetype","text":"IKOR SIP Archetype Description How to create a SIP Adapter using SIP Archetype","title":"IKOR SIP Archetype"},{"location":"archetype/#description","text":"This archetype creates a basic SIP Adapter project with a defined structure and necessary dependencies","title":"Description"},{"location":"archetype/#how-to-create-a-sip-adapter-using-sip-archetype","text":"In order to make setting up a new integration adapter project an easy task, we have created a dedicated SIP (Adapter) Maven archetype, that gives the ability to quickly bootstrap a new integration adapter, along with all needed Maven dependencies and goodies, as well as the recommended, preferred organization of the project. To make a long story short, you can create a SIP Adapter by using the following Maven command: mvn archetype:generate \\ -DarchetypeGroupId=de.ikor.sip.foundation \\ -DarchetypeArtifactId=sip-archetype \\ -DarchetypeVersion=<latest.sip-archetype.version> \\ -DgroupId=de.ikor.sip.adapter \\ -DartifactId=demo \\ -DprojectName=DemoAdapter \\ -Dversion=1.0.0-SNAPSHOT When executing the command, pay attention to use the latest archetype version for the -DarchetypeVersion parameter. The parameters -DgroupId , -DartifactId , -DprojectName and -Dversion should be adjusted to better match your project, as they set the properties for the adapter. It is recommended to follow the maven naming convention. After executing maven command, you will be requested to insert additional parameters about project structure: packageSuffix is used to create project package name by concatenating its value to the groupId. There is a strict validation for using only lower case letters and it is meant to name the package by extending your groupId for only one word. package (optional) is used to override previous package naming and provide full package name. This can be skipped by leaving value empty. It is strongly recommended to follow package naming convention, otherwise your project will be created but it will consist package naming errors. systemConnector1 / systemConnector2 are representing names of your connector modules inside the project. Naming recommendation is to use lower case letters and kebab-case. systemConnector1Package / systemConnector2Package are used to define package name suffix for the connectors. Notice that connector package name starts with prefix defined on package step. After a successful build, a project with the 4 following modules will be created: {artifactId}-application {artifactId}-domain {systemConnector1} {systemConnector2} Our recommendation for modules naming is shown on the following Partner Adapter example: partner-adapter-application partner-adapter-domain partner-connector-{arbitrary connector1 name} partner-connector-{arbitrary connector2 name} More about modules and internal SIP structure you can find here . More information about Maven archetypes is available here: Maven Archetype","title":"How to create a SIP Adapter using SIP Archetype"},{"location":"changelog/","text":"Changelog \u00b6 All notable changes to this project will be documented in this file. [Unreleased] \u00b6 For unreleased changelogs look into the changelogs directory 1.0.0 - 2021-11-18 \u00b6 \ud83d\ude80 Major Changes \u00b6 This is the initial version of the SIP framework. For more information on how to use it and details about features, please refer to the README and to our documentation on https://ikor-gmbh.github.io/sip-framework/. #15 by dannikore","title":"Changelog"},{"location":"changelog/#changelog","text":"All notable changes to this project will be documented in this file.","title":"Changelog"},{"location":"changelog/#unreleased","text":"For unreleased changelogs look into the changelogs directory","title":"[Unreleased]"},{"location":"changelog/#100-2021-11-18","text":"","title":"1.0.0 - 2021-11-18"},{"location":"changelog/#major-changes","text":"This is the initial version of the SIP framework. For more information on how to use it and details about features, please refer to the README and to our documentation on https://ikor-gmbh.github.io/sip-framework/. #15 by dannikore","title":"\ud83d\ude80 Major Changes"},{"location":"core/","text":"IKOR SIP Framework Core \u00b6 IKOR SIP Framework Core Description Usage Features Actuator health check and metrics Dynamic proxy for Apache Camel Processors Working with routes in runtime Logging Translation Changing log level programmatically Exchange tracing OpenAPI Descriptor Description \u00b6 Core project for base SIP functionalities Usage \u00b6 To enable SIP Core features use @SIPIntegrationAdapter to annotate the Spring Boot entry class. Features \u00b6 Actuator health check and metrics \u00b6 SIP Core provides out-of-the-box health checks for HTTP(S), JMS and FTP, SFTP and FTPS endpoints. Actuator can be accessed from {base_url}/actuator To customize health checks, or introduce health checks for other kinds of components, it is as simple as implementing the EndpointHealthConfigurer interface @Configuration public class EndpointMonitoringConfiguration { @Bean EndpointHealthConfigurer defaultHttpConfigurer() { return registry -> registry.register(\"http*://**\", HttpHealthIndicators::urlHealthIndicator); } @Bean EndpointHealthConfigurer ftpConfigurer() { return registry -> registry.register(\"*ftp*://**\", FtpHealthIndicators::noopHealthIndicator); } @Bean EndpointHealthConfigurer httpConfigurerById() { return registry -> registry.registerById(\"processor_id\", HttpHealthIndicators::urlHealthIndicator); } } There are a few possible ways to register health check indicators and they will be used in the following priority: by using the id of processor, it will be registered as the exact endpoint URI by using the exact endpoint URI as pattern by using wildcards (*) in pattern, priority is based on how close they match the URI default one for generic components If the same endpoint is used in more than one route, meaning multiple processors with different ids have the same endpoint uri, it is not possible to register 2 different health check functions (check important note below). Only one function per endpoint is possible. Important : If same uri pattern is specified more than one time by any of these methods, DuplicateUriPatternError will be thrown and application will not be able to start. Warning: Only one health indicator may exist for an exact endpoint URI. It is worth noting that the HTTP(S) Health Check lists all existing HTTP(S) endpoints by default, but sets the status to UNKNOWN. The reason for this is that for detected HTTP(S) endpoints a GET request is executed which may cause an unintended change of state of the system to be invoked. Thus this behavior does not occur, health checks should be added explicitly. To add an explicit Health Check for a URL it can be done in the following way. @Bean EndpointHealthConfigurer enableHttpHealthCheckForIKOR() { return registry -> registry.register(\"https://www.ikor.de\", HttpHealthIndicators::urlHealthIndicator); } In case the URL https://www.ikor.de/kontakt.html is requested by the adapter, then on the one hand the explicit URL could be passed as a parameter to register() or wildcards could be used to add a Health Check for this URL and at the same time also matches https://www.ikor.de/karriere.html. The passed argument to register() would look like this https://www.ikor.de/** . However, HTTP(S) Health Checks can only be added for URLs that have also been detected in the adapter. In order to find out what URLs have been discovered one could inspect the result of {base_url}/actuator/health . How to configure endpoint health checks: To inspect the health of Camel endpoints in an integration adapter, one needs to: Make sure that this project uses sip-integration-starter maven dependency. Instead of using @SpringBootApplication, use Java annotation @SIPIntegrationAdapter to annotate the Spring Boot entry class. Configure the application actuator's Health endpoint to display details of health, as shown below. All prerequisites from above are met if you create an integration adapter using SIP archetype. Spring Boot Actuator: #configuring health endpoint management: endpoint: health: show-details: always #or when_authorized if security is in place Dynamic proxy for Apache Camel Processors \u00b6 Dynamic proxy is implementation of decorator pattern on all Processors detected on all Camel routes. The base motivation is to gain more control over Camel dataflow, by providing placeholders for custom functionalities on different steps of the route. It's a mechanism for providing and applying new future features on already implemented adapters, through the configuration and without adapter code changes. During Camel route creation Processor Proxies are created and registered in ProcessorProxyRegistry. They can be accessed from registry through processor's ID. ProcessorProxyRegistry can be accessed as a spring bean or as an extension of CamelContext. The main feature for now is mock, which sets new behavior of a Camel processor and instead of using the real processor replace it with its mock. This can be achieved on any Processor on the route, including the outgoing endpoints. Mocking behavior with SIP can be triggered dynamically, and on single request level, leaving the original route intact and active all the time. To use it, header \"proxy-modes\" must be set, which consists of a map of processorIds as keys and list of commands as value: proxy-modes: {\"processorId\": [\"mock\"]} Setting mock behavior example: @Configuration public class MockConfiguration { private final ProcessorProxyRegistry proxyRegistry; public void mockProcessorBehavior(String processorId) { ProcessorProxy proxy = proxyRegistry .getProxy(processorId) .orElseThrow( () -> new RuntimeException(\"There is no \" + processorId + \" proxy in the application\")); proxy.mock(exchange -> {/*define mock behavior*/}); } //Reverts Processor to regular behavior public void resetProcessorProxy(ProcessorProxy proxy){ proxy.reset(); } } Working with routes in runtime \u00b6 All routes with basic info can be listed by using the following URI: GET /actuator/adapter-routes Getting only routes with sip middle component consumer: GET /actuator/adapter-routes/sipmc More detailed info view for only one exact route can be seen by providing route id into following URI: GET /actuator/adapter-routes/{routeId} The following operations (case sensitive) can be executed per route, for all route or on sipmc: start stop suspend resume reset To execute an operation on all routes, use following URIs: POST /actuator/adapter-routes/{operation} There is a possibility to execute a route lifecycle operation on an exact route, by providing route id and operation. This can be achieved by using following URI: POST /actuator/adapter-routes/{routeId}/{operation} Executing desired operation on the routes without providing route id is possible on sip middle component. By specifying operation on the following URI, operation will be executed for all routes which has sip middle component as a consumer: POST /actuator/adapter-routes/sipmc/{operation} Warning: When using suspend or stop operation on route that has middle component as a consumer, default value (30 seconds) timeout will be used. Keep in mind that if route is not started for next 30 seconds after sending data to middle component, data could be lost. Logging Translation \u00b6 Adds possibility to translate log messages By default, translation service is not activated, thus in order to use it a logback.xml file should be provided in resources. In this file we can specify that the adapter uses a custom logging encoder, which provides translations. <appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\"> <!-- encoders are by default assigned the type ch.qos.logback.classic.encoder.PatternLayoutEncoder --> <encoder class=\"de.ikor.sip.foundation.core.translate.logging.SIPPatternLayoutEncoder\"> <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36}: %msg%n</pattern> </encoder> </appender> Files for defining translation values, should be created inside translate directory as a bundle of .property files, under a common name, which should be extended by a suffix in following format _{language}. Each file consists of keys, shared in the bundle, followed by its value as a phrase in the language used. Warning: Be mindful of how MessageFormat handles String. Some characters, like apostrophe ('), are used as special characters and need to be escaped as shown in the example below. More details can be found here: MessageFormat amessagekey = A message value amessagekey.welcome_{} = Hello {0} amessagekey.missingbean = Bean {0} doesn''t exist The keys are automatically recognized and should be used in logs. log.info(\"amessagekey\"); log.info(\"amessagekey.welcome_{}\", \"A user\"); It can also be automatically used by Camel's log processor. In this case message key MUST be separated from parameters by blank space: .log(\"amessagekey\"); .log(\"amessagekey.welcome_{} ${header.userName}\"); Enabling, disabling and other settings can be done in the configuration. sip: core: translation: fileLocations: classpath:translations/translated-messages, classpath:translations/messages default-encoding: \"UTF-8\" fallback-to-system-locale: false use-code-as-default-message: true lang: en Changing log level programmatically \u00b6 Actuator enables us to dynamically change log levels of all loggers during runtime. This can be accomplished by using the following POST request: http://localhost:8080/actuator/loggers/{logger-name} Header: Content-Type: application/json Body: { \"configuredLevel\": \"TRACE\" } Log levels can be independently changed and will be individually set per logger or on root. We can also use logback.xml auto scan to update log levels. Here we need to enable auto scan and set the interval on which it occurs in logback.xml configuration, and then we can open logback.xml in target directory* and edit the log levels on loggers defined there. <configuration scan=\"true\" scanPeriod=\"30 seconds\"/> This works for all loggers except the ones on Camel routes. Exchange tracing \u00b6 SIP Core offers usage of Camel's built-in Tracer for tracing and logging information about all processor an exchange when through and TraceHistory service which stores all data logged by it. Configuration of the Tracer is enabled by adapting ExchangeFormatter. First we need to enable the following: sip: core: tracing: enabled: true Configuring the ExchangeFormatter can be achieved in two ways through configuration file sip: core: tracing: enabled: true exchange-formatter: multiline: true showHeaders: true showExchangeId: true showProperties: true maxChars: 100 by using the following POST request /actuator/tracing/format/{exchangeFormatterParameterName} The body of the request should include the value we want for the given parameter. TraceHistory is enabled with previous configuration. Exchanges will contain the \"tracingId\" header, which has the original Exchange's id as value. To see them in TraceHistory messages just set the \"showHeaders\" and \"showExchangeId\" parameters in ExchangeFormatter to true. A \"tracingId' header will appear and will be linked to the original Exchange's id. Expanding the traffic trace limit: Introduced the SipLimitedLinkedList in order to limit the number of logged events in memory. Default limit is 100 events, but it could be changed by following configuration: sip: core: tracing: limit: 120 #100 by default OpenAPI Descriptor \u00b6 Framework provides an Open API description of all custom or Spring provided endpoints within your adapter. Endpoints are created as extension of Spring's actuator. By using a sip-archetype code generator, you receive an adapter with a default setup for OpenAPI. For working with Swagger OpenAPI, check their official documentation . Adding Custom Swagger Docs: SIP Framework provides a Swagger documentation for the actuator endpoints out of the box. In case a custom Swagger documentation is needed it could be added by including the Swagger Apache Camel component. This component is only supporting the REST DSL component. For controller classes annotated with @RestController an entry is added to the default swagger docs. This might not be the expected behavior for which reason the REST DSL component is recommended. The custom Swagger documentation could easily be added by defining it in the restConfiguration as seen in the following listing. restConfiguration() .contextPath(\"/adapter\") .apiContextPath(\"/api-docs\") .apiContextRouteId(\"api-docs\"); If the application has a route based on the REST DSL a Swagger documentation is generated automatically. rest(\"/api/v1\") .tag(\"Data Controller\").description(\"REST service for creating new objects\") .consumes(MediaType.APPLICATION_JSON_VALUE).produces(MediaType.APPLICATION_JSON_VALUE) .post(\"/data\") .type(DataRequest.class) .description(\"Create a new object\") .outType(DataResponse.class) .to(\"direct:handleRequest\"); This will create a new Swagger documentation for the REST service. For further informations see the Apache Camel documentation of the Swagger and REST DSL component. In case the custom Swagger documentation should be displayed by default in the Swagger UI you can configure it accordingly in the application.yaml file. springdoc: show-actuator: true api-docs: path: /api-docs #default swagger docs swagger-ui: url: /adapter/api-docs #custom swagger docs set as default path: /swagger-ui.html Based on this configuration the custom Swagger documentation is accessible by /adapter/api-docs .","title":"Core"},{"location":"core/#ikor-sip-framework-core","text":"IKOR SIP Framework Core Description Usage Features Actuator health check and metrics Dynamic proxy for Apache Camel Processors Working with routes in runtime Logging Translation Changing log level programmatically Exchange tracing OpenAPI Descriptor","title":"IKOR SIP Framework Core"},{"location":"core/#description","text":"Core project for base SIP functionalities","title":"Description"},{"location":"core/#usage","text":"To enable SIP Core features use @SIPIntegrationAdapter to annotate the Spring Boot entry class.","title":"Usage"},{"location":"core/#features","text":"","title":"Features"},{"location":"core/#actuator-health-check-and-metrics","text":"SIP Core provides out-of-the-box health checks for HTTP(S), JMS and FTP, SFTP and FTPS endpoints. Actuator can be accessed from {base_url}/actuator To customize health checks, or introduce health checks for other kinds of components, it is as simple as implementing the EndpointHealthConfigurer interface @Configuration public class EndpointMonitoringConfiguration { @Bean EndpointHealthConfigurer defaultHttpConfigurer() { return registry -> registry.register(\"http*://**\", HttpHealthIndicators::urlHealthIndicator); } @Bean EndpointHealthConfigurer ftpConfigurer() { return registry -> registry.register(\"*ftp*://**\", FtpHealthIndicators::noopHealthIndicator); } @Bean EndpointHealthConfigurer httpConfigurerById() { return registry -> registry.registerById(\"processor_id\", HttpHealthIndicators::urlHealthIndicator); } } There are a few possible ways to register health check indicators and they will be used in the following priority: by using the id of processor, it will be registered as the exact endpoint URI by using the exact endpoint URI as pattern by using wildcards (*) in pattern, priority is based on how close they match the URI default one for generic components If the same endpoint is used in more than one route, meaning multiple processors with different ids have the same endpoint uri, it is not possible to register 2 different health check functions (check important note below). Only one function per endpoint is possible. Important : If same uri pattern is specified more than one time by any of these methods, DuplicateUriPatternError will be thrown and application will not be able to start. Warning: Only one health indicator may exist for an exact endpoint URI. It is worth noting that the HTTP(S) Health Check lists all existing HTTP(S) endpoints by default, but sets the status to UNKNOWN. The reason for this is that for detected HTTP(S) endpoints a GET request is executed which may cause an unintended change of state of the system to be invoked. Thus this behavior does not occur, health checks should be added explicitly. To add an explicit Health Check for a URL it can be done in the following way. @Bean EndpointHealthConfigurer enableHttpHealthCheckForIKOR() { return registry -> registry.register(\"https://www.ikor.de\", HttpHealthIndicators::urlHealthIndicator); } In case the URL https://www.ikor.de/kontakt.html is requested by the adapter, then on the one hand the explicit URL could be passed as a parameter to register() or wildcards could be used to add a Health Check for this URL and at the same time also matches https://www.ikor.de/karriere.html. The passed argument to register() would look like this https://www.ikor.de/** . However, HTTP(S) Health Checks can only be added for URLs that have also been detected in the adapter. In order to find out what URLs have been discovered one could inspect the result of {base_url}/actuator/health . How to configure endpoint health checks: To inspect the health of Camel endpoints in an integration adapter, one needs to: Make sure that this project uses sip-integration-starter maven dependency. Instead of using @SpringBootApplication, use Java annotation @SIPIntegrationAdapter to annotate the Spring Boot entry class. Configure the application actuator's Health endpoint to display details of health, as shown below. All prerequisites from above are met if you create an integration adapter using SIP archetype. Spring Boot Actuator: #configuring health endpoint management: endpoint: health: show-details: always #or when_authorized if security is in place","title":"Actuator health check and metrics"},{"location":"core/#dynamic-proxy-for-apache-camel-processors","text":"Dynamic proxy is implementation of decorator pattern on all Processors detected on all Camel routes. The base motivation is to gain more control over Camel dataflow, by providing placeholders for custom functionalities on different steps of the route. It's a mechanism for providing and applying new future features on already implemented adapters, through the configuration and without adapter code changes. During Camel route creation Processor Proxies are created and registered in ProcessorProxyRegistry. They can be accessed from registry through processor's ID. ProcessorProxyRegistry can be accessed as a spring bean or as an extension of CamelContext. The main feature for now is mock, which sets new behavior of a Camel processor and instead of using the real processor replace it with its mock. This can be achieved on any Processor on the route, including the outgoing endpoints. Mocking behavior with SIP can be triggered dynamically, and on single request level, leaving the original route intact and active all the time. To use it, header \"proxy-modes\" must be set, which consists of a map of processorIds as keys and list of commands as value: proxy-modes: {\"processorId\": [\"mock\"]} Setting mock behavior example: @Configuration public class MockConfiguration { private final ProcessorProxyRegistry proxyRegistry; public void mockProcessorBehavior(String processorId) { ProcessorProxy proxy = proxyRegistry .getProxy(processorId) .orElseThrow( () -> new RuntimeException(\"There is no \" + processorId + \" proxy in the application\")); proxy.mock(exchange -> {/*define mock behavior*/}); } //Reverts Processor to regular behavior public void resetProcessorProxy(ProcessorProxy proxy){ proxy.reset(); } }","title":"Dynamic proxy for Apache Camel Processors"},{"location":"core/#working-with-routes-in-runtime","text":"All routes with basic info can be listed by using the following URI: GET /actuator/adapter-routes Getting only routes with sip middle component consumer: GET /actuator/adapter-routes/sipmc More detailed info view for only one exact route can be seen by providing route id into following URI: GET /actuator/adapter-routes/{routeId} The following operations (case sensitive) can be executed per route, for all route or on sipmc: start stop suspend resume reset To execute an operation on all routes, use following URIs: POST /actuator/adapter-routes/{operation} There is a possibility to execute a route lifecycle operation on an exact route, by providing route id and operation. This can be achieved by using following URI: POST /actuator/adapter-routes/{routeId}/{operation} Executing desired operation on the routes without providing route id is possible on sip middle component. By specifying operation on the following URI, operation will be executed for all routes which has sip middle component as a consumer: POST /actuator/adapter-routes/sipmc/{operation} Warning: When using suspend or stop operation on route that has middle component as a consumer, default value (30 seconds) timeout will be used. Keep in mind that if route is not started for next 30 seconds after sending data to middle component, data could be lost.","title":"Working with routes in runtime"},{"location":"core/#logging-translation","text":"Adds possibility to translate log messages By default, translation service is not activated, thus in order to use it a logback.xml file should be provided in resources. In this file we can specify that the adapter uses a custom logging encoder, which provides translations. <appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\"> <!-- encoders are by default assigned the type ch.qos.logback.classic.encoder.PatternLayoutEncoder --> <encoder class=\"de.ikor.sip.foundation.core.translate.logging.SIPPatternLayoutEncoder\"> <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36}: %msg%n</pattern> </encoder> </appender> Files for defining translation values, should be created inside translate directory as a bundle of .property files, under a common name, which should be extended by a suffix in following format _{language}. Each file consists of keys, shared in the bundle, followed by its value as a phrase in the language used. Warning: Be mindful of how MessageFormat handles String. Some characters, like apostrophe ('), are used as special characters and need to be escaped as shown in the example below. More details can be found here: MessageFormat amessagekey = A message value amessagekey.welcome_{} = Hello {0} amessagekey.missingbean = Bean {0} doesn''t exist The keys are automatically recognized and should be used in logs. log.info(\"amessagekey\"); log.info(\"amessagekey.welcome_{}\", \"A user\"); It can also be automatically used by Camel's log processor. In this case message key MUST be separated from parameters by blank space: .log(\"amessagekey\"); .log(\"amessagekey.welcome_{} ${header.userName}\"); Enabling, disabling and other settings can be done in the configuration. sip: core: translation: fileLocations: classpath:translations/translated-messages, classpath:translations/messages default-encoding: \"UTF-8\" fallback-to-system-locale: false use-code-as-default-message: true lang: en","title":"Logging Translation"},{"location":"core/#changing-log-level-programmatically","text":"Actuator enables us to dynamically change log levels of all loggers during runtime. This can be accomplished by using the following POST request: http://localhost:8080/actuator/loggers/{logger-name} Header: Content-Type: application/json Body: { \"configuredLevel\": \"TRACE\" } Log levels can be independently changed and will be individually set per logger or on root. We can also use logback.xml auto scan to update log levels. Here we need to enable auto scan and set the interval on which it occurs in logback.xml configuration, and then we can open logback.xml in target directory* and edit the log levels on loggers defined there. <configuration scan=\"true\" scanPeriod=\"30 seconds\"/> This works for all loggers except the ones on Camel routes.","title":"Changing log level programmatically"},{"location":"core/#exchange-tracing","text":"SIP Core offers usage of Camel's built-in Tracer for tracing and logging information about all processor an exchange when through and TraceHistory service which stores all data logged by it. Configuration of the Tracer is enabled by adapting ExchangeFormatter. First we need to enable the following: sip: core: tracing: enabled: true Configuring the ExchangeFormatter can be achieved in two ways through configuration file sip: core: tracing: enabled: true exchange-formatter: multiline: true showHeaders: true showExchangeId: true showProperties: true maxChars: 100 by using the following POST request /actuator/tracing/format/{exchangeFormatterParameterName} The body of the request should include the value we want for the given parameter. TraceHistory is enabled with previous configuration. Exchanges will contain the \"tracingId\" header, which has the original Exchange's id as value. To see them in TraceHistory messages just set the \"showHeaders\" and \"showExchangeId\" parameters in ExchangeFormatter to true. A \"tracingId' header will appear and will be linked to the original Exchange's id. Expanding the traffic trace limit: Introduced the SipLimitedLinkedList in order to limit the number of logged events in memory. Default limit is 100 events, but it could be changed by following configuration: sip: core: tracing: limit: 120 #100 by default","title":"Exchange tracing"},{"location":"core/#openapi-descriptor","text":"Framework provides an Open API description of all custom or Spring provided endpoints within your adapter. Endpoints are created as extension of Spring's actuator. By using a sip-archetype code generator, you receive an adapter with a default setup for OpenAPI. For working with Swagger OpenAPI, check their official documentation . Adding Custom Swagger Docs: SIP Framework provides a Swagger documentation for the actuator endpoints out of the box. In case a custom Swagger documentation is needed it could be added by including the Swagger Apache Camel component. This component is only supporting the REST DSL component. For controller classes annotated with @RestController an entry is added to the default swagger docs. This might not be the expected behavior for which reason the REST DSL component is recommended. The custom Swagger documentation could easily be added by defining it in the restConfiguration as seen in the following listing. restConfiguration() .contextPath(\"/adapter\") .apiContextPath(\"/api-docs\") .apiContextRouteId(\"api-docs\"); If the application has a route based on the REST DSL a Swagger documentation is generated automatically. rest(\"/api/v1\") .tag(\"Data Controller\").description(\"REST service for creating new objects\") .consumes(MediaType.APPLICATION_JSON_VALUE).produces(MediaType.APPLICATION_JSON_VALUE) .post(\"/data\") .type(DataRequest.class) .description(\"Create a new object\") .outType(DataResponse.class) .to(\"direct:handleRequest\"); This will create a new Swagger documentation for the REST service. For further informations see the Apache Camel documentation of the Swagger and REST DSL component. In case the custom Swagger documentation should be displayed by default in the Swagger UI you can configure it accordingly in the application.yaml file. springdoc: show-actuator: true api-docs: path: /api-docs #default swagger docs swagger-ui: url: /adapter/api-docs #custom swagger docs set as default path: /swagger-ui.html Based on this configuration the custom Swagger documentation is accessible by /adapter/api-docs .","title":"OpenAPI Descriptor"},{"location":"installation/","text":"Installation guide \u00b6 Installation guide Software requirements Java Virtual Machine Maven IDE Plugins Create the project How to create a SIP Adapter from Maven Archetype Software requirements \u00b6 Before getting started to develop a first adapter with SIP the following requirements should be fulfilled: Java Virtual Machine \u00b6 Recommendation for using Java 8 or higher https://www.java.com/en/download/manual.jsp Maven \u00b6 Maven downloaded from https://maven.apache.org/download.cgi For the Maven documentation see https://maven.apache.org/guides/ IDE \u00b6 IntelliJ - Download from https://www.jetbrains.com/idea/download/#section=windows Eclipse - Download from https://www.eclipse.org/downloads/ Plugins \u00b6 Lombok with IntelliJ https://projectlombok.org/setup/intellij Lombok with Eclipse https://projectlombok.org/setup/eclipse Apache Camel with IntelliJ (recommendation) https://plugins.jetbrains.com/plugin/9371-apache-camel Create the project \u00b6 How to create a SIP Adapter from Maven Archetype \u00b6 In order to make setting up a new integration adapter project an easy task, we have created a dedicated SIP (Adapter) Maven archetype, that gives the ability to quickly bootstrap a new integration adapter, along with all needed Maven dependencies and goodies, as well as the recommended, preferred organization of the project. To make a long story short, you can create a SIP Adapter by using the following Maven command: Creating an application using SIP archetype on the command line: mvn archetype:generate \\ -DarchetypeGroupId=de.ikor.sip.foundation \\ -DarchetypeArtifactId=sip-archetype \\ -DarchetypeVersion=<latest.sip-archetype.version> \\ -DgroupId=de.ikor.sip.adapter \\ -DartifactId=demo \\ -DprojectName=DemoAdapter \\ -Dversion=1.0.0-SNAPSHOT When executing the command, pay attention to use the latest archetype version for the -DarchetypeVersion parameter. The following parameters -DgroupId, -DartifactId, -DprojectName and -Dversion should be adjusted to better match your project, as they set the properties for the adapter. It is recommended to follow the maven naming convention. After executing maven command, you will be requested to insert additional parameters about project structure: packageSuffix is used to create project package name by concatenating its value to the groupId. There is a strict validation for using only lower case letters and it is meant to name the package by extending your groupId for only one word. package (optional) is a chance to override previous package naming and provide full package name. This can be skipped by leaving value empty. Following package naming convention is strongly recommended, otherwise your project will be created, but it will consist package naming errors. systemConnector1 / systemConnector2 are representing names of your connector modules inside the project. Naming recommendation is to use lower case letters and kebab-case. systemConnector1Package / systemConnector2Package are used to define package name suffix for the connectors. Notice that connector package name starts with prefix defined on package step. After a successful build, a project with the 4 following modules will be created: {artifactId}-application {artifactId}-domain {systemConnector1} {systemConnector2} Our recommendation for modules naming is shown on the following Partner Adapter example: partner-adapter-application partner-adapter-domain partner-connector-sap partner-connector-dopix More information about Maven archetypes is available here: Maven Archetype","title":"Installation Guide"},{"location":"installation/#installation-guide","text":"Installation guide Software requirements Java Virtual Machine Maven IDE Plugins Create the project How to create a SIP Adapter from Maven Archetype","title":"Installation guide"},{"location":"installation/#software-requirements","text":"Before getting started to develop a first adapter with SIP the following requirements should be fulfilled:","title":"Software requirements"},{"location":"installation/#java-virtual-machine","text":"Recommendation for using Java 8 or higher https://www.java.com/en/download/manual.jsp","title":"Java Virtual Machine"},{"location":"installation/#maven","text":"Maven downloaded from https://maven.apache.org/download.cgi For the Maven documentation see https://maven.apache.org/guides/","title":"Maven"},{"location":"installation/#ide","text":"IntelliJ - Download from https://www.jetbrains.com/idea/download/#section=windows Eclipse - Download from https://www.eclipse.org/downloads/","title":"IDE"},{"location":"installation/#plugins","text":"Lombok with IntelliJ https://projectlombok.org/setup/intellij Lombok with Eclipse https://projectlombok.org/setup/eclipse Apache Camel with IntelliJ (recommendation) https://plugins.jetbrains.com/plugin/9371-apache-camel","title":"Plugins"},{"location":"installation/#create-the-project","text":"","title":"Create the project"},{"location":"installation/#how-to-create-a-sip-adapter-from-maven-archetype","text":"In order to make setting up a new integration adapter project an easy task, we have created a dedicated SIP (Adapter) Maven archetype, that gives the ability to quickly bootstrap a new integration adapter, along with all needed Maven dependencies and goodies, as well as the recommended, preferred organization of the project. To make a long story short, you can create a SIP Adapter by using the following Maven command: Creating an application using SIP archetype on the command line: mvn archetype:generate \\ -DarchetypeGroupId=de.ikor.sip.foundation \\ -DarchetypeArtifactId=sip-archetype \\ -DarchetypeVersion=<latest.sip-archetype.version> \\ -DgroupId=de.ikor.sip.adapter \\ -DartifactId=demo \\ -DprojectName=DemoAdapter \\ -Dversion=1.0.0-SNAPSHOT When executing the command, pay attention to use the latest archetype version for the -DarchetypeVersion parameter. The following parameters -DgroupId, -DartifactId, -DprojectName and -Dversion should be adjusted to better match your project, as they set the properties for the adapter. It is recommended to follow the maven naming convention. After executing maven command, you will be requested to insert additional parameters about project structure: packageSuffix is used to create project package name by concatenating its value to the groupId. There is a strict validation for using only lower case letters and it is meant to name the package by extending your groupId for only one word. package (optional) is a chance to override previous package naming and provide full package name. This can be skipped by leaving value empty. Following package naming convention is strongly recommended, otherwise your project will be created, but it will consist package naming errors. systemConnector1 / systemConnector2 are representing names of your connector modules inside the project. Naming recommendation is to use lower case letters and kebab-case. systemConnector1Package / systemConnector2Package are used to define package name suffix for the connectors. Notice that connector package name starts with prefix defined on package step. After a successful build, a project with the 4 following modules will be created: {artifactId}-application {artifactId}-domain {systemConnector1} {systemConnector2} Our recommendation for modules naming is shown on the following Partner Adapter example: partner-adapter-application partner-adapter-domain partner-connector-sap partner-connector-dopix More information about Maven archetypes is available here: Maven Archetype","title":"How to create a SIP Adapter from Maven Archetype"},{"location":"integration-starter/","text":"SIP Integration Starter \u00b6 SIP Integration Starter Description Includes Usage Description \u00b6 Starter project used to add necessary predefined dependencies for development of integration adapters Includes \u00b6 IKOR SIP Components dependencies Camel dependencies Spring dependencies Usage \u00b6 Add sip-integration-starter dependency to project. <dependency> <groupId>de.ikor.sip.foundation</groupId> <artifactId>sip-integration-starter</artifactId> <version>${sip.integration.starter}</version> </dependency>","title":"Integration Starter"},{"location":"integration-starter/#sip-integration-starter","text":"SIP Integration Starter Description Includes Usage","title":"SIP Integration Starter"},{"location":"integration-starter/#description","text":"Starter project used to add necessary predefined dependencies for development of integration adapters","title":"Description"},{"location":"integration-starter/#includes","text":"IKOR SIP Components dependencies Camel dependencies Spring dependencies","title":"Includes"},{"location":"integration-starter/#usage","text":"Add sip-integration-starter dependency to project. <dependency> <groupId>de.ikor.sip.foundation</groupId> <artifactId>sip-integration-starter</artifactId> <version>${sip.integration.starter}</version> </dependency>","title":"Usage"},{"location":"license/","text":"Apache License Version 2.0, January 2004 http://www.apache.org/licenses/ TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION Definitions. \"License\" shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document. \"Licensor\" shall mean the copyright owner or entity authorized by the copyright owner that is granting the License. \"Legal Entity\" shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \"control\" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity. \"You\" (or \"Your\") shall mean an individual or Legal Entity exercising permissions granted by this License. \"Source\" form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files. \"Object\" form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types. \"Work\" shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below). \"Derivative Works\" shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof. \"Contribution\" shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \"submitted\" means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \"Not a Contribution.\" \"Contributor\" shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work. Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form. Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed. Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions: (a) You must give any other recipients of the Work or Derivative Works a copy of this License; and (b) You must cause any modified files to carry prominent notices stating that You changed the files; and (c) You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and (d) If the Work includes a \"NOTICE\" text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License. You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License. Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions. Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file. Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License. Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages. Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability. END OF TERMS AND CONDITIONS APPENDIX: How to apply the Apache License to your work. To apply the Apache License to your work, attach the following boilerplate notice, with the fields enclosed by brackets \"[]\" replaced with your own identifying information. (Don't include the brackets!) The text should be enclosed in the appropriate comment syntax for the file format. We also recommend that a file or class name and description of purpose be included on the same \"printed page\" as the copyright notice for easier identification within third-party archives. Copyright [yyyy] [name of copyright owner] Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"middle-component/","text":"IKOR SIP Middle Component \u00b6 IKOR SIP Middle Component Description How to use Examples Description \u00b6 SIP middle component relates to the key SIP concept - splitting integration logic into submodules (connectors). Combining connectors into one data flow is quite easy with Camel and can be done in many ways. However, if we do it with one of Camel's existing component, we couldn't be sure if it represents connection between connectors or just some intermediate routing within the single connector. If we (properly) use sipmc component, it provides a clear functional and visual distinction between a connector's ending or beginning. With it, adapter routes become more standardized and manageable. Middle component is also a point of higher control over Apache Camel flow, as it provides a placeholder for future customizations which will make it easier to bridge connectors in different ways, e.g. by using JMS broker implicitly if configured. Middle component hides connecting technology and makes connection of two sub-systems abstract and simple. Current version supports only in-memory connection channel implemented on top of Camel's SEDA component. It provides 1 to 1 and publish-subscribe patterns and can support many channels in single adapter. Middle component can automatically determine the number of consumers for a specific channel and auto-configure itself accordingly, as a 1 to 1 or publish-subscribe connector. How to use \u00b6 Middle component is used like any other Camel component, but has a simple URI pattern: sipmc:channelName The channel name is an arbitrary String value, but it should relate to one integration topic, e.q. partner. Multiple sipmc routes may exist with different channel names. Examples \u00b6 1 to 1: In this scenario response provided by \"mock:output\" should be propagated back to the caller - \"mock:input\" from(\"mock:input\") .to(\"sipmc:foo\"); from(\"sipmc:foo\") .to(\"mock:output\"); Publish subscribe: With publish-subscribe pattern the caller (mock-input) does not know how many consumers are registered. Middle component makes sure the message is delivered to all of them. Notice that the URIs do not differ too much from the ones in previous case. from(\"mock:input\") .to(\"sipmc:foo\"); from(\"sipmc:foo\") .to(\"mock:output1\"); from(\"sipmc:foo\") .to(\"mock:output2\");","title":"Middle Component"},{"location":"middle-component/#ikor-sip-middle-component","text":"IKOR SIP Middle Component Description How to use Examples","title":"IKOR SIP Middle Component"},{"location":"middle-component/#description","text":"SIP middle component relates to the key SIP concept - splitting integration logic into submodules (connectors). Combining connectors into one data flow is quite easy with Camel and can be done in many ways. However, if we do it with one of Camel's existing component, we couldn't be sure if it represents connection between connectors or just some intermediate routing within the single connector. If we (properly) use sipmc component, it provides a clear functional and visual distinction between a connector's ending or beginning. With it, adapter routes become more standardized and manageable. Middle component is also a point of higher control over Apache Camel flow, as it provides a placeholder for future customizations which will make it easier to bridge connectors in different ways, e.g. by using JMS broker implicitly if configured. Middle component hides connecting technology and makes connection of two sub-systems abstract and simple. Current version supports only in-memory connection channel implemented on top of Camel's SEDA component. It provides 1 to 1 and publish-subscribe patterns and can support many channels in single adapter. Middle component can automatically determine the number of consumers for a specific channel and auto-configure itself accordingly, as a 1 to 1 or publish-subscribe connector.","title":"Description"},{"location":"middle-component/#how-to-use","text":"Middle component is used like any other Camel component, but has a simple URI pattern: sipmc:channelName The channel name is an arbitrary String value, but it should relate to one integration topic, e.q. partner. Multiple sipmc routes may exist with different channel names.","title":"How to use"},{"location":"middle-component/#examples","text":"1 to 1: In this scenario response provided by \"mock:output\" should be propagated back to the caller - \"mock:input\" from(\"mock:input\") .to(\"sipmc:foo\"); from(\"sipmc:foo\") .to(\"mock:output\"); Publish subscribe: With publish-subscribe pattern the caller (mock-input) does not know how many consumers are registered. Middle component makes sure the message is delivered to all of them. Notice that the URIs do not differ too much from the ones in previous case. from(\"mock:input\") .to(\"sipmc:foo\"); from(\"sipmc:foo\") .to(\"mock:output1\"); from(\"sipmc:foo\") .to(\"mock:output2\");","title":"Examples"},{"location":"security/","text":"SIP Security \u00b6 SIP Security Introduction Dependency Contents SSL Authentication Additional information Introduction \u00b6 What is SIP Security? SIP Security is built on top of Spring Security and is trying to ease and streamline the usage of Security related aspects, but also add some enterprise grade features which are, from our perspective, quite relevant and helpful. Why use it? Nowadays, security is one of the most important topics in every application. Implementing code and configuration on top of Spring Security should help you jump-start your adapter development (along with the archetype), not waste your time, and enable you to focus on your core tasks - resolving integration problems. Dependency \u00b6 <dependency> <groupId>de.ikor.sip.foundation</groupId> <artifactId>sip-security</artifactId> </dependency> Contents \u00b6 Following description shows SIP Security functionalities and configuration. SSL \u00b6 SSL is by default turned off. It can be activated by setting a server side certificate or turning the client SSL explicitly on and optionally setting a client certificate. If no server certificate is set a client certificate is mandatory when turning on client SSL. Client (our application is consuming APIs using the provided certificate) sip.security: ssl: client: enabled: true #true / false (default); if enabled but no other configs are made, server keystore is used as client certificate key-store: classpath:keystore.p12 # possible resource strings are classpath:, file:, http:, _none_ key-store-password: password # we recommend to use env_vars or sealed secrets key-store-type: pkcs12 #possible options are pkcs12, jks, jceks key-alias: springboot #the alias of the key to be chosen from the container key-password: password # we recommend to use env_vars or sealed secrets To turn the usage of a specific client certificate off (default): sip.security: ssl: client: enabled: false The truststore is handled with Java default: set the cacerts in the runtime accordingly (preferrable approach) for local development you could add any certificate, IntermediateCA, RootCA or complete certificate chain to the keystore as a trusted certificate (e.g. by importing it with tools like keytool), a possible command could be: keytool -importcert -file certificate.cer -keystore keystore.jks -alias \"Alias\" Server (our application is providing APIs using the provided certificate) sip.security: ssl: server: key-store: classpath:keystore.p12 # possible resource strings are classpath:, file:, http:, _none_ key-store-password: password # we recommend to use env_vars or sealed secrets key-store-type: pkcs12 #possible options are pkcs12, jks, jceks key-alias: springboot #the alias of the key to be chosen from the container key-password: password # we recommend to use env_vars or sealed secrets To turn the usage of the server certificate off: sip.security: ssl: server: enabled: false Authentication \u00b6 Global authentication configuration: sip.security: authentication: enabled: true #turn on/off all authentication functionality disable-csrf: true ignored-endpoints: #a list of endpoints which are ignored by ALL authenticators based on Spring\u00b4s AntPathMatchers implementation - /actuator - /actuator/** - /favicon.ico Extractors (extract the relevant token from an http-requests) BasicAuth: Extracts the BasicAuth credentials from the request X509: Extracts the X509 certificate from the request Providers (triggers a Validator to validate a given authentication) BasicAuth: Takes the extracted basic auth token and uses the given validator from the configuration to validate the token X509: Takes the extracted X509 token and uses the given validator from the configuration to validate the token Validators (validates a given token) BasicAuth sip.security: authentication: enabled: true #turn on/off all authentication functionality auth-providers: - classname: de.ikor.sip.foundation.security.authentication.basic.SIPBasicAuthAuthenticationProvider ignored-endpoints: #a list of endpoints which are ignored by this specific authenticator based on Spring\u00b4s AntPathMatchers implementation - /actuator/health - /actuator/env validation: classname: de.ikor.sip.foundation.security.authentication.basic.SIPBasicAuthFileValidator #FQCN of the validator to be used file-path: classpath:basic-auth-users.json # possible resource strings are classpath:, file:, http:, _none_ Sample file basic-auth-users.json : [ {\"username\": \"user1\", \"password\": \"pw1\"}, {\"username\": \"anotherUser\", \"password\": \"anotherPassword\"} ] X509 Configuration: sip.security: authentication: enabled: true #turn on/off all authentication functionality auth-providers: - classname: de.ikor.sip.foundation.security.authentication.x509.SIPX509AuthenticationProvider ignored-endpoints: #a list of endpoints which are ignored by this specific authenticator based on Spring\u00b4s AntPathMatchers implementation - /favicon.ico - /actuator/env validation: classname: de.ikor.sip.foundation.security.authentication.x509.SIPX509FileValidator #FQCN of the validator to be used file-path: classpath:client-certs.acl # possible resource strings are classpath:, file:, http:, _none_ Sample file client-certs.acl : CN=Full Name, EMAILADDRESS=name@domain.de, O=[*], C=DE CN=Full Name2, EMAILADDRESS=name2@domain.de, O=[*], C=DE Additional information \u00b6 ACL in the context of SIP Security and X509 is our implementation of an Access Control List . SIPX509FileValidator uses a given .acl file to grant access to respective users. This SIP specific feature is not related to Spring Security\u00b4s ACL implementation. The high-level intention is to limit the access to the provided API. If this feature is used client certificates are needed. To set the password for configuration value sip.security.ssl.server.key-store-password by environment variable you can do the following in your (bash) shell (Spring will automatically find the correct variable and set the value): export SIP_SECURITY_SSL_SERVER_KEY_STORE_PASSWORD=\"password\"","title":"Security"},{"location":"security/#sip-security","text":"SIP Security Introduction Dependency Contents SSL Authentication Additional information","title":"SIP Security"},{"location":"security/#introduction","text":"What is SIP Security? SIP Security is built on top of Spring Security and is trying to ease and streamline the usage of Security related aspects, but also add some enterprise grade features which are, from our perspective, quite relevant and helpful. Why use it? Nowadays, security is one of the most important topics in every application. Implementing code and configuration on top of Spring Security should help you jump-start your adapter development (along with the archetype), not waste your time, and enable you to focus on your core tasks - resolving integration problems.","title":"Introduction"},{"location":"security/#dependency","text":"<dependency> <groupId>de.ikor.sip.foundation</groupId> <artifactId>sip-security</artifactId> </dependency>","title":"Dependency"},{"location":"security/#contents","text":"Following description shows SIP Security functionalities and configuration.","title":"Contents"},{"location":"security/#ssl","text":"SSL is by default turned off. It can be activated by setting a server side certificate or turning the client SSL explicitly on and optionally setting a client certificate. If no server certificate is set a client certificate is mandatory when turning on client SSL. Client (our application is consuming APIs using the provided certificate) sip.security: ssl: client: enabled: true #true / false (default); if enabled but no other configs are made, server keystore is used as client certificate key-store: classpath:keystore.p12 # possible resource strings are classpath:, file:, http:, _none_ key-store-password: password # we recommend to use env_vars or sealed secrets key-store-type: pkcs12 #possible options are pkcs12, jks, jceks key-alias: springboot #the alias of the key to be chosen from the container key-password: password # we recommend to use env_vars or sealed secrets To turn the usage of a specific client certificate off (default): sip.security: ssl: client: enabled: false The truststore is handled with Java default: set the cacerts in the runtime accordingly (preferrable approach) for local development you could add any certificate, IntermediateCA, RootCA or complete certificate chain to the keystore as a trusted certificate (e.g. by importing it with tools like keytool), a possible command could be: keytool -importcert -file certificate.cer -keystore keystore.jks -alias \"Alias\" Server (our application is providing APIs using the provided certificate) sip.security: ssl: server: key-store: classpath:keystore.p12 # possible resource strings are classpath:, file:, http:, _none_ key-store-password: password # we recommend to use env_vars or sealed secrets key-store-type: pkcs12 #possible options are pkcs12, jks, jceks key-alias: springboot #the alias of the key to be chosen from the container key-password: password # we recommend to use env_vars or sealed secrets To turn the usage of the server certificate off: sip.security: ssl: server: enabled: false","title":"SSL"},{"location":"security/#authentication","text":"Global authentication configuration: sip.security: authentication: enabled: true #turn on/off all authentication functionality disable-csrf: true ignored-endpoints: #a list of endpoints which are ignored by ALL authenticators based on Spring\u00b4s AntPathMatchers implementation - /actuator - /actuator/** - /favicon.ico Extractors (extract the relevant token from an http-requests) BasicAuth: Extracts the BasicAuth credentials from the request X509: Extracts the X509 certificate from the request Providers (triggers a Validator to validate a given authentication) BasicAuth: Takes the extracted basic auth token and uses the given validator from the configuration to validate the token X509: Takes the extracted X509 token and uses the given validator from the configuration to validate the token Validators (validates a given token) BasicAuth sip.security: authentication: enabled: true #turn on/off all authentication functionality auth-providers: - classname: de.ikor.sip.foundation.security.authentication.basic.SIPBasicAuthAuthenticationProvider ignored-endpoints: #a list of endpoints which are ignored by this specific authenticator based on Spring\u00b4s AntPathMatchers implementation - /actuator/health - /actuator/env validation: classname: de.ikor.sip.foundation.security.authentication.basic.SIPBasicAuthFileValidator #FQCN of the validator to be used file-path: classpath:basic-auth-users.json # possible resource strings are classpath:, file:, http:, _none_ Sample file basic-auth-users.json : [ {\"username\": \"user1\", \"password\": \"pw1\"}, {\"username\": \"anotherUser\", \"password\": \"anotherPassword\"} ] X509 Configuration: sip.security: authentication: enabled: true #turn on/off all authentication functionality auth-providers: - classname: de.ikor.sip.foundation.security.authentication.x509.SIPX509AuthenticationProvider ignored-endpoints: #a list of endpoints which are ignored by this specific authenticator based on Spring\u00b4s AntPathMatchers implementation - /favicon.ico - /actuator/env validation: classname: de.ikor.sip.foundation.security.authentication.x509.SIPX509FileValidator #FQCN of the validator to be used file-path: classpath:client-certs.acl # possible resource strings are classpath:, file:, http:, _none_ Sample file client-certs.acl : CN=Full Name, EMAILADDRESS=name@domain.de, O=[*], C=DE CN=Full Name2, EMAILADDRESS=name2@domain.de, O=[*], C=DE","title":"Authentication"},{"location":"security/#additional-information","text":"ACL in the context of SIP Security and X509 is our implementation of an Access Control List . SIPX509FileValidator uses a given .acl file to grant access to respective users. This SIP specific feature is not related to Spring Security\u00b4s ACL implementation. The high-level intention is to limit the access to the provided API. If this feature is used client certificates are needed. To set the password for configuration value sip.security.ssl.server.key-store-password by environment variable you can do the following in your (bash) shell (Spring will automatically find the correct variable and set the value): export SIP_SECURITY_SSL_SERVER_KEY_STORE_PASSWORD=\"password\"","title":"Additional information"},{"location":"starter-parent/","text":"SIP Starter Parent \u00b6 SIP Starter Parent Description Usage Description \u00b6 This project takes care of versions (transitive dependencies) for Spring Boot and Camel dependencies. It inherits spring-boot-parent-starter, so that it will, by default, bring everything needed for comfortable development of Spring Boot applications. This includes transitive dependency management of all dependencies used by the Spring Boot starters, but also other dependencies for SIP Adapters, plus additional Maven plugin management and configuration. Usage \u00b6 This project should be used as parent for SIP Adapters. <parent> <groupId>de.ikor.sip.foundation</groupId> <artifactId>sip-starter-parent</artifactId> <version>${sip.starter.parent}</version> </parent>","title":"Starter Parent"},{"location":"starter-parent/#sip-starter-parent","text":"SIP Starter Parent Description Usage","title":"SIP Starter Parent"},{"location":"starter-parent/#description","text":"This project takes care of versions (transitive dependencies) for Spring Boot and Camel dependencies. It inherits spring-boot-parent-starter, so that it will, by default, bring everything needed for comfortable development of Spring Boot applications. This includes transitive dependency management of all dependencies used by the Spring Boot starters, but also other dependencies for SIP Adapters, plus additional Maven plugin management and configuration.","title":"Description"},{"location":"starter-parent/#usage","text":"This project should be used as parent for SIP Adapters. <parent> <groupId>de.ikor.sip.foundation</groupId> <artifactId>sip-starter-parent</artifactId> <version>${sip.starter.parent}</version> </parent>","title":"Usage"}]}